[中文版](./README-zh.md)
| [日本語版](./README-ja.md)
| [한국어](./README-ko.md)
| [Русский](./README-ru.md)
| [Português](./README-pt-BR.md)
| [Italiana](./README-it.md)
| [English](./README.md)
| [Persian/فارسی](./README-ir.md)

<p align="right">
  <a href="https://www.elsewhen.com/">
    <img src="./images/elsewhen-logo.png" width="180" height="180">
  </a>
</p>

# دستورالعمل‌های پروژه &middot; [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square)](http://makeapullrequest.com)

> وقتی که شروع و توسعه یک پروژه جدید برای شما شبیه به حرکت در یک میدان سبز و خالی (که هیچ ساختاری ندارد) است (استعاره از شروع کردن یک پروژه یا کار جدید از ابتدا و بدون هیچ محدودیت و ساختاری است)، نگهداری از آن می‌تواند کابوسی پیچیده و تاریک برای شخص دیگری باشد.
> در اینجا لیستی از دستورالعمل‌ها آمده است که ما آن‌ها را پیدا کرده‌ایم، نوشته‌ایم و گردآوری کرده‌ایم و فکر می‌کنیم که برای اکثر پروژه‌های جاوااسکریپت در [elsewhen](https://www.elsewhen.com) به خوبی عمل می‌کند.
> اگر می‌خواهید یک روش بهینه را به اشتراک بگذارید، یا فکر می‌کنید یکی از این دستورالعمل‌ها باید حذف شود، [با خیال راحت آن را با ما به اشتراک بگذارید](http://makeapullrequest.com).

<hr>

- [گیت (Git)](#git)
  - [برخی از قوانین Git](#some-git-rules)
  - [گردش کار گیت (Git Workflow)](#git-workflow)
  - [نگارش بهتر متن کامیت‌ها](#writing-good-commit-messages)
- [مستندات (Documentation)](#documentation)
- [متغیرهای محیطی (Environments)](#environments)
  - [ایجاد محیط‌های توسعه‌ی یکپارچه (Consistent Dev Environments)](#consistent-dev-environments)
  - [وابستگی‌های یکسان و هماهنگ (Consistent Dependencies)](#consistent-dependencies)
- [وابستگی‌ها (Dependencies)](#dependencies)
- [تست کردن (Testing)](#testing)
- [ساختار و نام‌گذاری (Structure and Naming)](#structure-and-naming)
- [سبک کدنویسی (Code Style)](#code-style)
  - [برخی اصول Code Style](#code-style-check)
  - [اعمال استانداردهای کدنویسی](#enforcing-code-style-standards)
- [ثبت وقایع (Logging)](#logging)
- [ای‌پی‌آی (API)](#api)
  - [طراحی API](#api-design)
  - [امنیت ای‌پی‌آی (API security)](#api-security)
  - [مستندسازی ای‌پی‌آی (API documentation)](#api-documentation)
- [دسترس‌پذیری (Accessibility)](#a11y)
- [مجوزدهی/Licensing](#licensing)

<a name="git"></a>

## 1. گیت (Git)

<p align="right">
  <img src="/images/branching.png" width="135" height="135">
</p>

<a name="some-git-rules"></a>

### 1.1 برخی از قوانین Git

در کار با Git، رعایت مجموعه‌ای از قوانین و اصول ضروری است که در ادامه به آن‌ها اشاره شده است:

- کار را در برنچ `feature` انجام دهید

_چرا:_

> کار بر روی برنچ‌ feature باعث می‌شود تمام تغییرات به صورت مجزا و در یک برنچ اختصاصی اعمال شوند. این روش به شما این امکان را می‌دهد که چندین Pull Request ارسال کنید بدون اینکه دچار سردرگمی شوید. همچنین، می‌توانید کد خود را مکرراً به‌روزرسانی کنید، بدون اینکه برنچ اصلی را با کدهای ناپایدار و ناتمام آلوده کنید. ([توضیحات بیشتر ...](https://www.atlassian.com/git/tutorials/comparing-workflows#feature-branch-workflow))

- از برنچ `develop` انشعاب بگیرید

_چرا:_

> با انشعاب از برنچ `develop،` می‌توانید مطمئن باشید که کد موجود در برنچ `master` همیشه پایدار و قابل `build` است و معمولاً می‌توان آن را مستقیماً برای انتشار/releases استفاده کرد (البته این رویکرد ممکن است برای برخی از پروژه‌ها بیش از حد یا فراتر از نیاز باشد).

- هرگز به برنچ `develop` یا `master` مستقیماً Push نکنید، بلکه یک درخواست Pull Request ایجاد کنید.

_چرا:_

> هرگز به برنچ‌های `develop` یا `master` مستقیماً Push نکنید. به جای آن، یک Pull Request ایجاد کنید. این کار به اعضای تیم اطلاع می‌دهد که یک feature تکمیل شده است و امکان بررسی کد توسط سایرین و بحث درباره تغییرات را فراهم می‌کند.

- قبل از Push کردن یک فیچر و ایجاد Pull Request، ابتدا برنچ `develop` محلی/local خود را به‌روزرسانی کنید و یک ری‌بیس (Rebase) تعاملی انجام دهید.

_چرا:_

> قبل از ارسال Pull Request، برنچ `develop` یا `master` محلی خود را به‌روزرسانی کرده و Rebase تعاملی انجام دهید. Rebase تغییرات محلی شما را به بالای تاریخچه انتقال می‌دهد و از ایجاد Commitهای غیرضروری جلوگیری می‌کند. این کار باعث تمیز و مرتب شدن تاریخچه Commitها می‌شود. ([توضیحات بیشتر ...](https://www.atlassian.com/git/tutorials/merging-vs-rebasing))

- تعارضات احتمالی را در حین `rebase` برطرف کنید و سپس Pull Request ایجاد کنید. (این کار به شفافیت و کیفیت کد کمک می‌کند.)

- برنچ‌های `feature` ایجاد شده، پس از اتمام کار و ادغام باید حذف شوند (در `local` و `remote`).

_چرا:_

> حذف برنچ‌های ادغام شده باعث می‌شود لیست برنچ‌ها شلوغ نشود و هر برنچ تنها یک بار به برنچ اصلی (`master` یا `develop`) ادغام شود. برنچ‌های `feature` فقط باید تا زمانی که کار هنوز در حال انجام است، وجود داشته باشند.

- قبل از ایجاد Pull Request، مطمئن شوید که برنچ `feature` شما به درستی `build` می‌شود و تمامی تست‌ها (از جمله بررسی سبک و استایل کدنویسی) موفقیت‌آمیز هستند.

_چرا:_

> زمانی‌که شما تصمیم دارید کد خود را به یک برنچ stable اضافه کنید، اگر تست‌های برنچ `feature` محلی/local ناموفق باشند، احتمال زیادی وجود دارد که `build` برنچ مقصد نیز با خطا مواجه شود. علاوه بر این، قبل از ایجاد درخواست Pull Request، ضروری است که بررسی سبک و استایل کدنویسی انجام گردد. زیرا این کار باعث بهبود خوانایی و استانداردسازی کد می‌شود و از شکست احتمالی `build` برنچ مقصد جلوگیری می‌کند.

- [از فایل](./.gitignore) `.gitignore` استفاده کنید.

_چرا:_

> فایل `.gitignore` فایل‌ها و دایرکتوری‌هایی که نباید به مخزن `remote` ارسال شوند (مانند فایل‌های سیستمی و تنظیمات ویرایشگرها) را مستثنی می‌کند. این کار از ارسال فایل‌های غیرضروری جلوگیری می‌کند.

- از برنچ‌های `develop` و `master` محافظت کنید.

_چرا:_

> این کار از برنچ‌های آماده برای production در برابر دریافت تغییرات غیرمنتظره و غیرقابل بازگشت محافظت می‌کند. توضیحات بیشتر را برای [GitHub](https://help.github.com/articles/about-protected-branches/), [Bitbucket](https://confluence.atlassian.com/bitbucketserver/using-branch-permissions-776639807.html) و [GitLab](https://docs.gitlab.com/ee/user/project/protected_branches.html) بخوانید.

<a name="git-workflow"></a>

### 1.2 گردش کار گیت (Git Workflow)

با توجه به دلایل اشاره‌شده، ما از روش [Feature Branch Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows#feature-branch-workflow) به همراه [Interactive Rebasing](https://www.atlassian.com/git/tutorials/merging-vs-rebasing#the-golden-rule-of-rebasing) و برخی عناصر [Gitflow](https://www.atlassian.com/git/tutorials/comparing-workflows#gitflow-workflow) (مانند نام‌گذاری شاخه‌ها و استفاده از برنچ `develop`) بهره می‌بریم. مراحل کلی آن به‌صورت زیر است:

- برای یک پروژه جدید، یک مخزن گیت (Git repository) را در پوشه پروژه ایجاد کنید. برای ویژگی‌ها یا تغییرات بعدی، دیگر نیازی به انجام این مرحله نیست.

```sh
cd <project directory>
git init
```

- یک شاخه جدید برای توسعه یک `feature` یا رفع یک `bug` ایجاد کنید و به آن سوئیچ کنید.

```sh
git checkout -b <branchname>
```

- اعمال تغییرات در فایل‌ها و ثبت آن‌ها

```sh
git add <file1> <file2> ...
git commit
```

_چرا:_

> با دستور `git add <file1> <file2> ...` باید تنها فایل‌هایی را اضافه کنید که یک تغییر کوچک و منسجمی را تشکیل می‌دهند.

> دستور `git commit` یک ویرایشگری را باز می‌کند که در آن می‌توانید متن کامیت خود را با جداسازی بخش موضوع (`subject`) از بدنه (`body`) بنویسید.

> در _بخش 1.3_ درباره‌ی آن توضیح بیشتری داده شده است.

_نکته:_

> می‌توانید به‌جای این دستور، از `git add -p` استفاده کنید تا تغییرات را به صورت مرحله‌به‌مرحله (hunk-by-hunk) بررسی کرده و تصمیم بگیرید کدام بخش در کامیت قرار بگیرد.

- برنچ لوکال خود را با مخزن `remote` همگام‌سازی کنید تا تغییرات جدید را دریافت کنید.

```sh
git checkout develop
git pull
```

_چرا:_

> این کار به شما این فرصت را می‌دهد که با conflictها در سیستم خود در حین rebasing و پیش از ارسال Pull Request مواجه شوید، به جای آنکه یک درخواست Pull Request ایجاد کنید که حاوی conflict و تضاد باشد.

- برنچ `feature` خود را با استفاده از interactive rebase با آخرین تغییرات از برنچ `develop`، به‌روزرسانی کنید.

```sh
git checkout <branchname>
git rebase -i --autosquash develop
```

_چرا:_

> با گزینه‌ی `--autosquash` می‌توانید تمام کامیت‌های خود را در برنچ `feature` در یک کامیت ترکیب کنید تا تاریخچه مرتب‌تری داشته باشید. زیرا هیچ‌کس تمایل ندارد برای یک ویژگی، چندین کامیت پراکنده در برنچ `develop` داشته باشد. ([توضیحات بیشتر ...](https://robots.thoughtbot.com/autosquashing-git-commits))

- اگر با conflictای مواجه شدید، [آن را برطرف کنید](https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/) و rebase را ادامه دهید، در غیر این صورت، می‌توانید این مرحله را نادیده بگیرید.

```sh
git add <file1> <file2> ...
git rebase --continue
```

- برنچ خود را پس از ری‌بیس `push` کنید. از آنجا که rebase تاریخچه‌ی برنچ را تغییر می‌دهد، Git جلوی Push عادی را می‌گیرد؛ بنابراین باید از `-f` برای اعمال اجباری تغییرات استفاده کنید. اگر افراد دیگری نیز روی برنچ شما کار می‌کنند، بهتر است از گزینه کمتر مخرب `--force-with-lease` استفاده کنید.

```sh
git push -f
```

_چرا:_

> وقتی که rebase انجام می‌دهید، گیت تاریخچه برنچ feature محلی را تغییر می‌دهید. در نتیجه، گیت جلوی Push عادی با استفاده از دستور `git push` را می‌گیرد. بنابراین باید از فلگ `-f` یا `--force` برای اعمال اجباری تغییرات استفاده کنید. ([توضیحات بیشتر ...](https://developer.atlassian.com/blog/2015/04/force-with-lease/))

- پس از Push کردن برنچ، یک Pull Request خود را ایجاد کنید.

- یک نفر از اعضای تیم یا مسئول بررسی کد، درخواست Pull Request را پس از بررسی، پذیرفته و آن را ادغام (Merge) کند، درنتیجه این درخواست بسته خواهد شد.

- در صورت اتمام کار،برنچ `feature` محلی خود را حذف کنید.

```sh
git branch -d <branchname>
```

جهت حذف تمام برنچ‌های محلی که دیگر در مخزن remote وجود ندارند، از دستور زیر استفاده کنید. (برای تمیز نگه‌داشتن محیط توسعه و حذف برنچ‌های قدیمی)

```sh
git fetch -p && for branch in `git branch -vv --no-color | grep ': gone]' | awk '{print $1}'`; do git branch -D $branch; done
```

<a name="writing-good-commit-messages"></a>

### 1.3 نگارش بهتر متن کامیت‌ها

داشتن راهنمای مناسب و پایبندی به آن برای نوشتن پیام‌های کامیت، همکاری با دیگران و نگهداری پروژه را بسیار ساده‌تر می‌کند. در اینجا چند قانون کلی وجود دارد ([منبع](https://chris.beams.io/posts/git-commit/#seven-rules)):

- موضوع (`subject`) را از بدنه (`body`) جدا کنید و بین این دو بخش یک خط خالی بگذارید.

_چرا:_

> گیت به اندازه کافی هوشمند است که خط اول پیام کامیت شما را به‌عنوان خلاصه تشخیص دهد. اگر به‌جای استفاده از `git log` از `git shortlog` استفاده کنید، فقط این خط اول (خلاصه) را به همراه شناسه کامیت خواهید دید.

- طول خط موضوع (`subject`) را تا 50 کاراکتر محدود نگه دارید و بدنه‌ی پیام (`body`) را حداکثر در 72 کاراکتر قرار دهید.

_چرا:_

> این کار باعث می‌شود کامیت‌ها تا حد ممکن متمرکز و خوانا باشند؛ نیازی به طولانی‌نویسی نیست. ([توضیحات بیشتر](https://medium.com/@preslavrachev/what-s-with-the-50-72-rule-8a906f61f09c))

- حرف اول موضوع (`subject`) را با عبارت بزرگ (Capitalize) شروع کنید.

- موضوع (`subject`) را با نقطه تمام نکنید.

- از [وجه امری](https://en.wikipedia.org/wiki/Imperative_mood) در موضوع (`subject`) استفاده کنید.

_چرا:_

> به جای نوشتن پیام‌هایی که فقط بیانگر یا توصیف‌کننده کاری هستند، بهتر است متن کامیت را به عنوان یک دستورالعمل‌ در نظر بگیرید تا مشخص کنند که پس از ادغام کامیت در مخزن، چه کاری قرار است انجام شود. ([توضیحات بیشتر ...](https://news.ycombinator.com/item?id=2079612))

- از قسمت بدنه (`body`) برای توضیح چرایی و چیستی کار انجام‌شده استفاده کنید، نه چگونگی انجام آن.

<a name="documentation"></a>

## 2. مستندات (Documentation)

<p align="right">
  <img src="/images/documentation.png" alt="Documentation" width="128" height="128">
</p>

- از این [ساختار](./README.sample.md) برای فایل `README.md` پروژه خود استفاده کنید؛ اگر بخش‌هایی وجود دارد که پوشش داده نشده است، می‌توانید آن‌ها را به‌دلخواه اضافه کنید.

- اگر پروژه‌تان چندین مخزن (repository) دارد، لینک هر مخزن را در فایل‌های `README.md` مربوطه درج کنید.

- با پیشرفت پروژه، فایل `README.md` را به‌روز نگه دارید تا همیشه منعکس‌کننده آخرین وضعیت باشد.

- برای درک بهتر بخش‌های اصلی کد، کد خود را کامنت‌گذاری کنید، همچنین سعی کنید که به‌وضوح توضیح دهید که قصد انجام چه کاری را دارید.

- اگر درباره کد یا روش مورد استفاده شما در گیت‌هاب یا استک‌اورفلو بحثی باز وجود دارد، لینک آن را در کامنت خود بگنجانید، تا سایر توسعه‌دهندگان بتوانند به بحث ایجاد شده دسترسی داشته باشند.

- کامنت‌ها نباید توجیهی برای کد ضعیف باشند. کد خود را تا حد امکان تمیز بنویسید.

- در عین حال از ارائه توضیحات تکمیلی در قالب کامنت، به این بهانه که کد تمیز می‌باشد، غافل نشوید.

- با پیشرفت کد، کامنت‌ها را هم به‌روز کنید تا با وضعیت فعلی پروژه همخوانی داشته باشند.

<a name="environments"></a>

## 3. متغیرهای محیطی (Environments)

<p align="right">
  <img src="/images/laptop.png" alt="Environments" width="128" height="128">
</p>

- در صورت نیاز، برای مراحل مختلف پروژه مانند `development`، `test` و `production،` محیط‌های جداگانه تعریف کنید.

_چرا:_

> هر محیط‌ (environment) مختلف ممکن است data، tokens، APIs، ports و... متفاوتی نیاز داشته باشند. به‌عنوان مثال، می‌توانید در حالت `development` از APIهای جعلی با داده‌های قابل پیش‌بینی استفاده کنید تا تست‌های دستی و خودکار ساده‌تر شوند. یا شاید بخواهید Google Analytics را فقط در محیط `production` فعال کنید و به همین ترتیب. ([توضیحات بیشتر ...](https://stackoverflow.com/questions/8332333/node-js-setting-up-environment-specific-configs-to-be-used-with-everyauth))

- پیکربندی‌های مختص هر محیط را به عنوان مقادیر ثابت در کد قرار ندهید، بلکه از متغیرهای محیطی (environment variables) برای جدا کردن پیکربندی هر محیط استفاده کنید ([به این نمونه نگاه کنید](./config.sample.js)).

_چرا:_

> متغیرهای محیطی ممکن است شامل توکن‌ها، رمزعبورها و سایر اطلاعات حساس باشند. قرار دادن این اطلاعات در کد باعث می‌شود در صورت عمومی شدن کد، این اطلاعات نیز فاش شوند.

_چگونه:_

> از فایل‌های `.env` برای ذخیره متغیرهای محیطی استفاده کنید و آن‌ها را در فایل `.gitignore` قرار دهید تا به مخزن remote ارسال نشوند. در عوض، یک فایل `.env.example` را کامیت کنید تا توسعه‌دهندگان دیگر از آن به‌عنوان راهنما استفاده کنند. برای محیط `production` همچنان به شیوه استاندارد متغیرهای محیطی را تنظیم کنید. ([توضیحات بیشتر](https://medium.com/@rafaelvidaurre/managing-environment-variables-in-node-js-2cb45a55195f))

- پیش از اجرای برنامه، متغیرهای محیطی را (مثلاً با استفاده از کتابخانه‌ای مانند `joi`) اعتبارسنجی کنید تا خطاهای احتمالی زودتر شناسایی شوند. ([نمونه](./configWithTest.sample.js))

_چرا:_

> این کار باعث می‌شود خطاهای احتمالی را زودتر شناسایی کنید و از هدررفتن ساعت‌ها مشکل‌یابی/troubleshooting توسط دیگران جلوگیری می‌کند.

> <a name="consistent-dev-environments"></a>

### 3.1 ایجاد محیط‌های توسعه‌ی یکپارچه (Consistent Dev Environments):

- نسخه‌ی Node را در بخش `engines` در فایل `package.json` وارد کنید.

_چرا:_

> در بخش `engines`، نسخه‌ی Node را مشخص کنید تا سایر توسعه‌دهندگان بدانند پروژه با کدام نسخه کار می‌کند. ([توضیحات بیشتر ...](https://docs.npmjs.com/files/package.json#engines))

- علاوه‌براین، از `nvm` استفاده کنید و یک فایل `.nvmrc` در ریشه‌ی پروژه ایجاد کنید و در مستندات به آن اشاره کنید.

_چرا:_

> تا هر کسی که از `nvm` استفاده می‌کند، بتواند به سادگی با اجرای `nvm use` بتواند به نسخه‌ی مناسب Node سوئیچ کند. ([توضیحات بیشتر ...](https://github.com/creationix/nvm))

- می‌توانید یک اسکریپت `preinstall` تنظیم کنید تا نسخه‌های Node و npm را بررسی کند.

_چرا:_

> زیرا برخی وابستگی‌ها (dependencies) ممکن است در صورت نصب توسط نسخه‌های جدیدتر npm دچار خطا شوند.

- در صورت امکان از Docker استفاده کنید.

_چرا:_

> این کار می‌تواند یک محیط سازگار در کل فرآیند کاری شما فراهم کند، بدون نیاز به تنظیمات یا وابستگی‌های پیچیده. ([توضیحات بیشتر …](https://hackernoon.com/how-to-dockerize-a-node-js-application-4fbab45a0c19))

- از پکیج‌های محلی (local) به‌جای پکیج‌های سراسری (globally) استفاده کنید.

_چرا:_

> این کار به شما اجازه می‌دهد پکیج‌های استفاده شده را با همکارانتان به اشتراک بگذارید، به جای آنکه انتظار داشته باشید آن‌ها به‌صورت سراسری روی سیستم خود نصب کرده باشند.

<a name="consistent-dependencies"></a>

### 3.2 وابستگی‌های یکسان و هماهنگ (Consistent Dependencies):

- اطمینان حاصل کنید که اعضای تیم دقیقاً همان وابستگی‌ها (dependencies) را مانند شما دریافت کنند.

_چرا:_

> برای اطمینان از این‌که پروژه در هر محیطی یکسان اجرا می‌شود و خطاهای پیش‌بینی‌نشده رخ ندهد. ([توضیحات بیشتر ...](https://kostasbariotis.com/consistent-dependencies-across-teams/))

_چگونه:_

> در نسخه‌های 5 یا بالاتر `npm`، از فایل `package-lock.json` استفاده کنید.

_اگر از `npm` قدیمی‌تر از نسخه 5 استفاده می‌کنید:_

> می‌توانید از `Yarn` بهره ببرید، مطمئن شوید در فایل `README.md` به این موضوع اشاره شده است. پس از هر به‌روزرسانی وابستگی‌ها، فایل lock file و فایل `package.json` باید با یکدیگر همخوانی داشته باشند. ([توضیحات بیشتر ...](https://yarnpkg.com/en/))

_اگر `Yarn` را نمی‌پسندید:_

> متأسفانه راه دیگری ندارید. در نسخه‌های قدیمی `npm`، هنگام نصب وابستگی جدید از `--save --save-exact` استفاده کنید و قبل از انتشار، فایل `npm-shrinkwrap.json` را بسازید. ([توضیحات بیشتر ...](https://docs.npmjs.com/files/package-locks))

<a name="dependencies"></a>

## 4. وابستگی‌ها (Dependencies)

<p align="right">
  <img src="/images/modules.png" alt="modules" width="128" height="128">
</p>

- پکیچ‌های نصب‌شده را ردیابی و نظارت کنید: به عنوان مثال، با اجرای دستور `npm ls --depth=0`، می‌توانید فهرست پکیج‌های سطح اول پروژه‌تان را مشاهده کنید و از وضعیت آن‌ها مطلع شوید. (این کار کمک می‌کند بدانید چه کتابخانه‌هایی در حال حاضر در پروژه نصب هستند و آیا همه آن‌ها مورد استفاده قرار می‌گیرند یا خیر.) ([توضیحات بیشتر ...](https://docs.npmjs.com/cli/ls))

- پکیج‌های بی‌استفاده یا نامربوط را با استفاده از ابزار depcheck شناسایی کنید. ([توضیحات بیشتر ...](https://www.npmjs.com/package/depcheck))

_چرا:_

> با استفاده از ابزار `depcheck` می‌توانید کتابخانه‌های غیرضروری را که تنها باعث افزایش حجم پروژه شده‌اند را بیابید و حذف کنید.

- قبل از استفاده از یک پکیچ، با بهره‌گیری از `npm-stat` می‌توانید میزان دانلود و محبوبیت یک پکیج را در جامعه برنامه‌نویسان بسنجید. ([توضیحات بیشتر ...](https://npm-stat.com/))

_چرا:_

> هرچه جامعه استفاده‌کنندگان بزرگ‌تر باشد، احتمال نگهداری بهتر و کشف سریع‌تر باگ‌ها بیشتر خواهد بود.

- پیش از افزودن یک وابستگی جدید، نسخه‌های منظم و فعال بودن تیم نگهدارنده (maintainers) را بررسی و ارزیابی کنید. به عنوان مثال، می‌توانید از دستور `npm view async` کمک بگیرید. ([توضیحات بیشتر ...](https://docs.npmjs.com/cli/view))

_چرا:_

> اگرچه تعداد بالا و فعالیت مداوم نگهدارندگان، می‌تواند روند رفع باگ‌ها و توسعه را تسهیل بکند، اما اگر مشارکت‌کنندگان نتوانند اصلاحات (`fixes`) و وصله‌ها (`patches`) را با سرعت کافی ادغام (`merge`) کنند، داشتن مشارکت‌کننده‌ی زیاد چندان مؤثر نخواهد بود.

- اگر قصد دارید از کتابخانه‌ای کمتر شناخته‌شده (غیرمشهور) استفاده کنید، ابتدا با اعضای تیم خود مشورت نمایید.

- همیشه از به‌روزبودن وابستگی‌ها با آخرین نسخه، اطمینان حاصل کنید. می‌توانید با اجرای دستور `npm outdated` وضعیت نسخه‌های فعلی پکیج‌ها را بررسی کنید. ([توضیحات بیشتر ...](https://docs.npmjs.com/cli/outdated))

_چرا:_

> پیش از بروزرسانی، حتماً Release Notes را مطالعه کرده و اگر تغییرات مخربی وجود دارد، آن‌ها را به‌صورت مرحله‌به‌مرحله اعمال کنید تا در صورت بروز مشکل، عیب‌یابی آسان‌تر باشد. ابزاری مانند [npm-check-updates](https://github.com/tjunnone/npm-check-updates) نیز در این زمینه مفید است.

- همواره پیش از اضافه کردن یا بروزرسانی یک پکیج، مشکلات امنیتی احتمالی آن را بررسی کنید. برای نمونه، [Snyk](https://snyk.io/test?utm_source=risingstack_blog) به شما گزارش‌های امنیتی مربوط به پکیج موردنظر را ارائه می‌دهد.

<a name="testing"></a>

## 5. تست کردن (Testing)

<p align="right">
  <img src="/images/testing.png" alt="testing" width="128" height="128">
</p>

- در صورت نیاز، یک محیط تست (test environment) ایجاد کنید.

_چرا:_

> در برخی پروژه‌ها، تست End-to-End در محیط `production` ممکن است کافی به نظر برسد، اما مواقعی پیش می‌آید که یک محیط تست جداگانه ضروری است. به‌عنوان مثال، ممکن است مایل نباشید در حالت `production` داده‌های آزمایشی ایجاد کنید یا اطلاعات تحلیلی کاربران را تحت تأثیر قرار دهید. همچنین ممکن است API شما در حالت `production` دارای محدودیت تعداد درخواست (rate limit) باشد که اجرای تست‌ها را در آن دشوار کند.

- فایل‌های تست را در کنار فایل اصلی قرار دهید. با استفاده از الگوی نام‌گذاری خاصی مانند `*.test.js` یا `*.spec.js`، مانند `moduleName.spec.js`.

_چرا:_

> تا به‌راحتی قابل یافتن باشند و نیاز به جستجو و پیمایش در ساختار پروژه نباشد. ([توضیحات بیشتر ...](https://hackernoon.com/structure-your-javascript-code-for-testability-9bc93d9c72dc))

- ممکن است برخی از تست‌ها به فایل‌های پیاده‌سازی خاصی مربوط نباشد، دراین‌صورت آن‌ها را در یک دایرکتوری مجزا قرار دهید.

_چرا:_

> ممکن است برخی از تست‌ها به فایل‌های پیاده‌سازی خاصی مربوط نباشد، دراین‌صورت آن‌ها را در یک دایرکتوری مجزا مانند `__test__` قرار دهید. این نام‌گذاری `__test__` هم اکنون یک استاندارد است و در اکثر فریم‌ورک‌های تست جاوااسکریپت نیز شناخته شده می‌باشند.

- کدهایی بنویسید که منطقی واضح داشته باشند و بتوان آن‌ها را مستقل از هر عامل خارجی (side effect) آزمایش کرد و نتیجه یکسان بدهد (pure functions).

_چرا:_

> هر بخش از منطق کسب‌وکار (business logic) باید به صورت مستقل و جداگانه مورد آزمایش و تست قرار گیرد تا مطمئن شوید که آن بخش‌ها به درستی کار می‌کند. باید "تأثیر عوامل تصادفی یا فرآیندهای غیرقابل‌پیش‌بینی را در کد به حداقل برسانید" [توضیحات بیشتر ...](https://medium.com/javascript-scene/tdd-the-rite-way-53c9b46f45e3)

> یک تابع خالص (pure function) تابعی است که همیشه برای ورودی یکسان، خروجی یکسانی را باز می‌گرداند. برعکس، یک تابع ناخالص (impure function) تابعی است که ممکن است اثرات جانبی داشته باشد یا برای تولید یک مقدار به شرایط خارجی وابسته باشد، که این امر باعث می‌شود کمتر قابل پیش‌بینی باشد. [توضیحات بیشتر ...](https://hackernoon.com/structure-your-javascript-code-for-testability-9bc93d9c72dc)

- از یک Static Type Checker استفاده کنید

_چرا:_

> ابزارهایی مانند Flow یا TypeScript می‌توانند با بررسی نوع (Type) متغیرها و توابع، سطح اطمینان کد را بالا ببرند و از بروز خطاهای پیش‌بینی‌نشده جلوگیری کنند. ([توضیحات بیشتر ...](https://medium.freecodecamp.org/why-use-static-types-in-javascript-part-1-8382da1e0adb))

- پیش از آنکه درخواست pull request به برنچ `develop` ارسال کنید، تست‌ها را به‌صورت locally اجرا کنید.

_چرا:_

> همیشه پیش از ارسال Pull Request، تست‌ها را در سیستم محلی (local) خود اجرا کنید و مطمئن شوید که هیچ موردی باعث شکست فرآیند Build در برنچ `develop` یا `production` نمی‌شود.

- در فایل `README.md` (یا هر مستند دیگری که پروژه استفاده می‌کند)، نحوه اجرای تست‌ها و نیازمندی‌های مرتبط را توضیح دهید.

_چرا:_

> این مستندات مانند یک یادداشت راهنما است که برای سایر اعضای تیم، کارشناسان DevOps، یا تیم تضمین کیفیت (QA) و هر کسی که با کد شما کار می‌کند، مفید خواهد بود.

<a name="structure-and-naming"></a>

## 6. ساختار و نام‌گذاری (Structure and Naming)

<p align="right">
  <img src="/images/folder-tree.png" alt="Structure and Naming" width="128" height="128">
</p>

- از سازمان‌دهی فایل‌ها بر اساس نقش (مانند قرار دادن همه فایل‌های `controllers` در یک پوشه و تمام فایل‌های `models` در پوشه‌ای دیگر) خودداری کنید. همچنین فایل‌های تست همان بخش را هم در همان پوشه بگذارید.

**ساختار نامطلوب**

```
.
├── controllers
|   ├── product.js
|   └── user.js
├── models
|   ├── product.js
|   └── user.js
```

**ساختار مطلوب**

```
.
├── product
|   ├── index.js
|   ├── product.js
|   └── product.test.js
├── user
|   ├── index.js
|   ├── user.js
|   └── user.test.js
```

_چرا:_

> به جای داشتن یک لیست طولانی از فایل‌ها، با داشتن ماژول‌های کوچک با مسئولیت‌های مشخص و خاص، می‌توانید دسترسی به فایل‌ها را ساده‌تر کرده و زمان جستجو را برای پیدا کردن یک فایل کاهش دهید.

- اگر تستی وجود دارد که به یک فایل خاص مرتبط نیست، آن را در پوشه‌ای با نام‌های متداولی مانند `test` یا `__test__` قرار دهید.

_چرا:_

> این کار از سردرگمی جلوگیری کرده و باعث می‌شود سایر هم‌تیمی‌ها یا کارشناسان DevOps راحت‌تر بتوانند فایل‌های تست را پیدا کرده و نیز موجب صرفه‌جویی در زمان می‌شود.

- از یک پوشه به نام `./config` برای تنظیمات استفاده کنید و از ایجاد فایل‌های پیکربندی جداگانه برای هر محیط (`development`، `test`، `production`) خودداری کنید.

_چرا:_

> در صورت افزایش استقرار (deployment)های برنامه، ممکن است محیط‌های بیشتری به پروژه اضافه شود و مدیریت آن‌ها پیچیده شود. بهتر است تنظیمات را در یک پوشه‌ی مشخص مانند `config` قرار دهید و مقادیر مورد نیاز را از طریق متغیرهای محیطی (environment variables) دریافت کنید. ([توضیحات بیشتر ...](https://medium.com/@fedorHK/no-config-b3f1171eecd5))

- اسکریپت‌های `bash`، `node` و یا هر اسکریپت اجرایی دیگری را در پوشه‌ی `./scripts` نگه دارید.

_چرا:_

> معمولاً به بیش از یک اسکریپت نیاز خواهید داشت (مانند اسکریپت ساخت نسخه production، ساخت نسخه توسعه development، اسکریپت‌های مرتبط با پایگاه داده و غیره).

- فایل‌های تولیدشده (مانند فایل‌های bundle، کامپایل‌شده، و ترنسپایل‌شده) را در پوشه‌ی `./build` قرار دهید و در فایل `.gitignore` نیز آن را مستثنی کنید.

_چرا:_

> نام‌گذاری آن به سلیقه شما بستگی دارد، `dist` نیز گزینه خوبی است، ولی این نام‌گذاری را با تیم خود هماهنگ کنید. فایل‌هایی که در این پوشه قرار می‌گیرند، قابل تولید مجدد هستند و هم‌تیمی‌ها شما نیز باید قادر به تولید آن باشند؛ در نتیجه نیازی به قراردادن آن‌ها در مخزن گیت نیست، مگر در شرایط خاص.

<a name="code-style"></a>

## 7. سبک کدنویسی (Code Style)

<p align="right">
  <img src="/images/code-style.png" alt="Code style" width="128" height="128">
</p>

<a name="code-style-check"></a>

### 7.1 برخی اصول Code Style

- در پروژه‌های جدید از ویژگی‌های جدید جاوااسکریپت (Stage 2 و بالاتر) بهره ببرید. برای پروژه‌های قدیمی، در صورت عدم تمایل به مهاجرت، سینتکس قبلی را حفظ کنید، مگر اینکه قصد به‌روزرسانی آن را داشته باشید.

_چرا:_

> این موضوع به تصمیم شما بستگی دارد. بهره‌گیری از ترنسپایلرها (مانند Babel) استفاده از قابلیت‌های جدید زبان را آسان می‌کند. ویژگی‌های Stage 2 معمولاً با تغییرات جزئی بخشی از استاندارد زبان خواهند شد.

- از اجرای بررسی سبک کدنویسی (Code Style) به‌عنوان بخشی از فرآیند Build پروژه، اطمینان حاصل کنید.

_چرا:_

> اگر خطاهای مربوط به سبک کدنویسی جلوی Build را بگیرند، توسعه‌دهندگان مجبور می‌شوند قوانین را رعایت کنند. این روش هم در کد سمت کاربر (Client) و هم در سمت سرور (Server) قابل اجراست. ([توضیحات بیشتر ...](https://www.robinwieruch.de/react-eslint-webpack-babel/))

- برای بررسی و اعمال سبک کدنویسی از [ESLint](http://eslint.org/) استفاده کنید.

_چرا:_

> ما `eslint` را ترجیح می‌دهیم، اما شما می‌توانید انتخاب دیگری داشته باشید. این ابزار قوانین بیشتری را پشتیبانی می‌کند، همچنین قابلیت تنظیم و افزودن قوانین سفارشی را دارد.

- ما از کد استایل [Airbnb](https://github.com/airbnb/javascript) برای جاوااسکریپت استفاده می‌کنیم، [بیشتر بخوانید](https://www.gitbook.com/book/duk/airbnb-javascript-guidelines/details). شما نیز می‌توانید هر کد استایلی که با نیاز پروژه یا تیمتان همخوانی دارد، به کار بگیرید.

- هنگام استفاده از [FlowType](https://flow.org/)، از پلاگین‌های مربوط به بررسی [سبک کدنویسی Flow برای ESLint](https://github.com/gajus/eslint-plugin-flowtype) بهره ببرید.

_چرا:_

> با استفاده از Flow اعضای تیم باید سبک کدنویسی خاصی را رعایت کنند.

- برای مستثنی‌کردن فایل‌ها و پوشه‌ها از بررسی سبک کدنویسی، از فایل `.eslintignore` استفاده کنید.

_چرا:_

> به‌جای شلوغ کردن کد با کامنت‌های `eslint-disable`، برای مستثنی‌کردن فایل‌ها و پوشه‌ها از بررسی سبک کدنویسی، از فایل `.eslintignore` استفاده کنید.

- تمام کامنت‌های `eslint-disable` خود را پیش از ارسال یک Pull Request حذف کنید.

_چرا:_

> ممکن است گاهی برای افزایش تمرکز روی یک بخش از منطق کد (Logic)، موقتاً بررسی سبک را غیرفعال کنید؛ اما به خاطر داشته باشید که پیش از ارسال Pull Request، این کامنت‌ها را جهت مطابقت کد با استانداردهای مشخص شده، حذف کنید.

- با در نظر داشتن حجم و اندازه کار، از کامنت‌های `//TODO:` یا ایجاد یک تیکت، استفاده کنید.

_چرا:_

> استفاده از کامنت‌های `//TODO:` به شما و همکارانتان کمک می‌کند تا وظایف کوچک مانند بازنویسی یک تابع یا به‌روزرسانی یک توضیح را به خاطر بسپارند. برای وظایف بزرگ‌تر، از فرمت `//TODO(#3456)` که توسط قوانین `lint` اعمال می‌شود، استفاده کنید، که شماره‌ی داخل پرانتز به یک تیکت باز در سیستم مدیریت پروژه اشاره می‌کند.

- همیشه کامنت‌ها را با تغییرات کد بروز نگه دارید. همچنین کدهایی که کامنت‌شده‌اند را نیز حذف کنید.

_چرا:_

> کد باید تا حد امکان خوانا باشد؛ بخش‌هایی از کد که استفاده نمی‌شوند را حذف کنید و کامنت‌ها را مطابق با تغییرات جدید به‌روزرسانی کنید. مثلاً اگر یک تابع را بازنویسی کردید، تابع قدیمی را فقط کامنت نکنید، بلکه آن را حذف کنید.

- از نام‌ها یا کامنت‌های طنزآمیز یا غیرمرتبط پرهیز کنید.

_چرا:_

> اگرچه در فرآیند build برنامه، ممکن است آن کامنت‌ها و شوخی‌ها به صورت خودکار حذف شوند، اما در برخی موارد سورس کد به سایر شرکت‌ها یا مشتری‌ها منتقل می‌شود که ممکن است آن‌ها این نوع شوخی‌ها را نپسندند.

- نام‌ها را به گونه‌ای انتخاب کنید که قابل جست‌وجو و معنادار باشند، از انتخاب نام‌های کوتاه‌شده و مخفف بپرهیزید. برای توابع، از نام‌های توصیفی و فعل‌محور استفاده کنید. نام تابع باید یک فعل یا عبارت فعلی باشد و هدف آن را به وضوح بیان کند.

_چرا:_

> این کار (استفاده از نام‌های کامل و توصیفی) باعث می‌شود کد خواناتر و درک آن راحت‌تر و ساده‌تر شود.

- توابع را بر اساس «قانون نزولی» (Step-Down Rule) سازمان‌دهی کنید؛ به این صورت که توابع سطح بالاتر را در بالای فایل و توابع سطح پایین‌تر را در پایین فایل قرار دهید.

_چرا:_

> این کار خوانایی کد را افزایش می‌دهد.

<a name="enforcing-code-style-standards"></a>

### 7.2 اعمال استانداردهای سبک کدنویسی

- از فایل `.editorconfig` استفاده کنید ([لینک](http://editorconfig.org/)) که به شما و سایر اعضای تیم کمک کند تا سبک‌های کدنویسی یکسانی را میان ویرایشگرها و IDEهای مختلف پروژه تعریف و حفظ کنید.

_چرا:_

> پروژه `EditorConfig` دربرگیرنده‌ی یک فایل برای تعریف سبک‌ و استال‌های کدنویسی است که شامل مجموعه‌ای از افزونه‌ها برای ویرایشگرها و IDEی مختلف است؛ که این امکان را می‌دهد که ویرایشگرها و IDEی مختلف از استایل‌های تعریف‌شده پیروی کنند.

- ویرایشگر را به شیوه‌ای راه‌اندازی و تنظیم کنید که برای خطاهای سبک کدنویسی (Code Style) هشدار دهد. از ترکیب پلاگین‌های [eslint-plugin-prettier](https://github.com/prettier/eslint-plugin-prettier) و [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier) در تنظیمات ESLint خود استفاده کنید. ([توضیحات بیشتر ...](https://github.com/prettier/eslint-config-prettier#installation))

- - استفاده از Git hooks را مدنظر قرار دهید.

_چرا:_

> با اجرای خودکار تست‌ها و بررسی Code Style پیش از Commit یا Push کردن تغییرات، می‌توانید مشکلات احتمالی را زودتر شناسایی کنید و از شکست Build پروژه در محیط‌‌های Staging یا Production جلوگیری کنید. ([توضیحات بیشتر ...](http://githooks.com/))

- از Prettier همراه با precommit hook استفاده کنید.

_چرا:_

> اگرچه `prettier` به‌خودی‌خود قدرتمند است، اما اجرای دستی `prettier` چندان کارآمد نیست. با بهره‌گیری از `lint-staged` و `husky`، می‌توانید هنگام Commit، کد را به‌صورت خودکار قالب‌بندی کنید. درباره پیکربندی `lint-staged` ([اینجا](https://github.com/okonet/lint-staged#configuration)) و پیکربندی `husky` ([اینجا](https://github.com/typicode/husky)) می‌توانید بیشتر مطالعه کنید.

<a name="logging"></a>

## 8. ثبت وقایع (Logging)

<p align="right">
  <img src="/images/logging.png" alt="Logging" width="128" height="128">
</p>

- استفاده از `console.log` در سمت کلاینت و در محیط Production خودداری کنید.

_چرا:_

> حتی اگر فرآیند Build شما لاگ‌ها را حذف می‌کند (که بهتر است حتماً این کار را انجام دهد)، به ابزار بررسی سبک کدنویسی (Lint) خود اجازه دهید باقی‌مانده‌های `console.log` را تشخیص و به شما هشدار دهد.

- برای تولید لاگ‌های خوانا در محیط production، بهتر است از کتابخانه‌های لاگ مناسب استفاده کنید (مانند [winston](https://github.com/winstonjs/winston) یا [node-bunyan](https://github.com/trentm/node-bunyan)).

_چرا:_

> به‌جای `console.log`، از کتابخانه‌هایی نظیر Winston یا node-bunyan استفاده کنید. این ابزارها امکاناتی مانند رنگ‌بندی، زمان‌بندی، و ثبت لاگ‌ها در فایل (علاوه بر کنسول) و حتی ثبت روزانه و بایگانی آن‌ها را در اختیار شما می‌گذارند. این قابلیت‌ها فرایند عیب‌یابی را آسان‌تر و کارآمدتر می‌کند. ([توضیحات بیشتر ...](https://blog.risingstack.com/node-js-logging-tutorial/))

<a name="api"></a>

## 9. ای‌پی‌آی (API)

<a name="api-design"></a>

<p align="right">
  <img src="/images/api.png" alt="API" width="128" height="128">
</p>

### 9.1 طراحی API

_چرا:_

> هدف از این بخش، طراحی رابط‌های RESTful است که منطقی و ساده باشند تا اعضای تیم و مشتریان بتوانند به‌سادگی و به‌صورت یکنواخت از آن‌ها استفاده کنند.

_چرا:_

> نبود هماهنگی و سادگی می‌تواند هزینه‌های یکپارچه‌سازی و نگهداری را به‌طور چشمگیری افزایش دهد. به همین دلیل، طراحی API در این مستند گنجانده شده است.

- ما عمدتاً از طراحی مبتنی بر منابع (Resource-Oriented Design) پیروی می‌کنیم که شامل سه عنصر اصلی است:
  1.  منابع (Resources):
      - شامل داده‌هایی هستند که می‌توانند به‌صورت تو در تو (nested) سازمان‌دهی شوند.
      - برای هر منبع، متدهایی برای انجام عملیات مختلف تعریف می‌شود.
  2.  مجموعه‌ها (Collections):
      - گروهی از منابع (Resources)، یک مجموعه (Collections) را تشکیل می‌دهند.
  3.  آدرس‌های اینترنتی (URLs):
      - مکان آنلاین یک منبع (Resource) یا مجموعه (Collection) را مشخص می‌کنند.

_چرا:_

> این شیوه یک استاندارد شناخته‌شده در بین توسعه‌دهندگان (مصرف‌کنندگان اصلی API) است. علاوه بر خوانایی و سادگی استفاده، اجازه می‌دهد کتابخانه‌ها و اتصال‌دهنده‌های عمومی بسازیم، بدون این‌که از ابتدا بدانیم API دقیقاً چه می‌کند.

- در طراحی مسیرهای (URL) از kebab-case استفاده کنید.

- برای پارامترهای موجود در Query String یا فیلدهای منبع، از camelCase استفاده کنید.

- نام منابع در URL باید به صورت kebab-case و جمع (plural) باشد.

- همیشه از اسامی جمع برای آدرس (URL)‌هایی که به یک مجموعه اشاره می‌کنند استفاده کنید: `/users`

_چرا:_

> به این دلیل که خوانایی بیشتری دارد و آدرس‌ها را یکدست نگه می‌دارد. ([برای اطلاعات بیشتر...](https://apigee.com/about/blog/technology/restful-api-design-plural-nouns-and-concrete-names))

- در سورس کد، اسامی جمع را به متغیرها و پراپرتی‌هایی با پسوند «List» تبدیل کنید. (مانند `userList` به جای `users`)

_چرا:_:

> استفاده از اسامی جمع در URL مناسب است، اما در سورس کد ممکن است به دلیل شباهت ظاهری به اسامی مفرد، منجر به اشتباهات و خطاهای برنامه‌نویسی شود. (تفاوت بین `user` و `users` تنها یک حرف `'s'` است که می‌تواند در خواندن و نگهداری کد مشکلاتی ایجاد کند. با افزودن پسوند `List`، نام متغیرها و ویژگی‌ها واضح‌تر و خواناتر می‌شوند و احتمال بروز خطا کاهش می‌یابد.)

- همیشه در طراحی URLها، ابتدا نام مجموعه (collection) را به صورت جمع ذکر کنید و سپس با استفاده از یک شناسه یکتا (identifier)، به یک منبع خاص در آن مجموعه اشاره کنید:

```
/students/245743
/airports/kjfk
```

- از URLهایی مانند این اجتناب کنید:

```
GET /blogs/:blogId/posts/:postId/summary
```

_چرا:_

> این نوع URL به جای اشاره به یک منبع (resource)، به یک ویژگی (property) یا خلاصه‌ای از منبع اشاره می‌کند. در RESTful APIها، URLها باید منابع (resource) را نمایندگی کنند، نه ویژگی‌های خاص آن‌ها را. برای دسترسی به ویژگی‌های خاص یا خلاصه‌ای از یک منبع، می‌توانید از کوئری پارامترها (query parameters) استفاده کنید تا بتوانید پاسخ را بر اساس نیاز خود تنظیم و محدود کنید. (به عنوان مثال، بهتر است به صورت `GET /blogs/:blogId/posts/:postId?fields=summary` استفاده شود. به این دلیل‌که URL به منبع `postId` در مجموعه `posts` مربوط به `blogId` اشاره می‌کند و با استفاده از کوئری پارامتر `fields=summary` مشخص شده است که فقط خلاصه‌ی مطلب، مورد نظر است.)

- افعال را از URLهای منابع خود حذف کنید.

_چرا:_

> زیرا اگر برای هر عملیات resource از یک فعل استفاده کنید، به زودی با لیستی بزرگ از URLها مواجه خواهید شد که الگوی ثابتی ندارند و یادگیری را برای توسعه‌دهندگان دشوار می‌کنند. علاوه بر این، ما از افعال برای چیز دیگری استفاده می‌کنیم.

- معمولاً از اسامی (nouns) در مسیرهای URL برای اشاره به منابع استفاده می‌شود. با این حال، در مواردی که نیاز به انجام عملیاتی دارید که به منبع خاصی مرتبط نیست (Non-resource) و در واقع یک عملکرد یا تابع را اجرا کرده و نتیجه را برمی‌گرداند، می‌توانید از افعال (verbs) در مسیرهای URL استفاده کنید. این عملیات‌ها مربوط به CRUD (ایجاد، دریافت، به‌روزرسانی، حذف) نیستند:

```
/translate?text=Hallo
```

_چرا:_

> برای عملیات‌های CRUD، از متدهای HTTP مانند `GET`، `POST`، `PUT` و `DELETE` بر روی URLهای منابع (resource) یا مجموعه‌ها (collection) استفاده می‌کنیم. اما در مواردی که عملیاتی خاص انجام می‌دهید که به منبع خاصی مرتبط نیست، استفاده از افعال در مسیرهای URL می‌تواند مناسب باشد. این نوع مسیرها معمولاً به عنوان "کنترلر" شناخته می‌شوند و تعداد آن‌ها در APIها معمولاً کم است. ([برای اطلاعات بیشتر...](https://github.com/byrondover/api-guidelines/blob/master/Guidelines.md#controller))

- اگر درخواست (Request Body) یا پاسخ (Response) در قالب `JSON` است، از `camelCase` برای نام پراپرتی‌های JSON پیروی کنید تا یکپارچگی و انسجام حفظ شود.

_چرا:_

> این راهنما و دستورالعمل برای پروژه‌ای مبتنی بر جاوااسکریپت تنظیم شده است. در نتیجه، فرض بر این است که تولید و پردازش `JSON` هم در همین زبان انجام می‌شود و پیروی از `camelCase` منطقی است.

- هرچند یک منبع (resource) مفهومی یکتا و مفرد است که مشابه با یک نمونه شیء یا رکورد در پایگاه داده می‌باشد، اما نباید از نام جدول‌های پایگاه داده (`table_name`) برای نام‌گذاری منابع و از نام ستون‌ها (`column_name`) برای ویژگی‌های منابع استفاده کنید.

_چرا:_

> هدف اصلی شما ارائه منابع به کاربران است، نه افشای جزئیات ساختار پایگاه داده. افشای مستقیم نام جدول‌ها و ستون‌ها می‌تواند امنیت سیستم را به خطر بیندازد و همچنین انعطاف‌پذیری API را در مواجهه با تغییرات داخلی کاهش دهد. با انتزاع‌سازی و استفاده از نام‌گذاری‌های مستقل از پایگاه داده، می‌توانید APIهایی منسجم‌تر، امن‌تر و قابل نگهداری‌تر ایجاد کنید.

- مجدداً تأکید می‌شود، در نام‌گذاری مسیر (URL) فقط از «اسم» استفاده کنید و از توضیح عملکرد آن بپرهیزید.

_چرا:_

> فقط از اسامی در URLهای منبع استفاده کنید و از مسیرهایی نظیر `/addNewUser` یا `/updateUser` خودداری کنید. همچنین از ارسال عملیات منبع به‌عنوان یک پارامتر خودداری کنید.

- عملیات‌های CRUD را با متدهای HTTP شرح دهید:

_چگونه:_

> متد `GET`: برای بازیابی نمایشی از یک منبع.

> متد `POST`: برای ایجاد منابع و زیرمنابع جدید.

> متد `PUT`: برای به‌روزرسانی منابع موجود.

> متد `PATCH`: برای به‌روزرسانی منابع موجود. فقط فیلدهای ارائه‌شده را به‌روزرسانی می‌کند و بقیه را دست‌نخورده می‌گذارد.

> متد `DELETE`: برای حذف منابع موجود.

- برای منابع تو در تو (Nested Resources)، توصیه می‌شود رابطه بین آن‌ها را از طریق شناسه‌ها (`id`)، در ساختار URL منعکس کنید. به‌عنوان مثال، با استفاده از `id` ارتباط یک کارمند با شرکت را نشان دهید.

_چرا:_

> این رویکردی طبیعی برای قابل پیمایش کردن منابع است.

_چگونه:_

> درخواست `GET /schools/2/students` باید لیست تمام دانش‌آموزان مدرسه 2 را بازگرداند.

> درخواست `GET /schools/2/students/31` باید اطلاعات دانش‌آموز شماره 31 مدرسه 2 را بازگرداند.

> درخواست `DELETE /schools/2/students/31` باید دانش‌آموز شماره 31 مدرسه 2 را حذف کند.

> درخواست `PUT /schools/2/students/31` باید اطلاعات دانش‌آموز شماره 31 را به‌روزرسانی کند. از `PUT` روی مسیر منبع (resource) استفاده می‌کنیم نه روی مسیر مجموعه (collection).

> درخواست `POST /schools` باید یک مدرسه جدید بسازد و جزئیات مدرسه تازه ایجاد شده را برگرداند. از `POST` روی آدرس مجموعه (collection) استفاده می‌کنیم.

- از یک عدد ترتیبی ساده با پیشوند `v` برای نسخه‌دهی استفاده کنید (مثال: `v1`, `v2`) و این نسخه را در ابتدای URL قرار دهید تا بیشترین دامنه تأثیرگذاری را داشته باشد:

```
http://api.domain.com/v1/schools/3/students
```

_چرا:_

> وقتی APIهای شما به‌طور عمومی برای اشخاص دیگر در دسترس هستند، انجام تغییرات ناسازگار (breaking changes)، می‌تواند باعث ایجاد اختلال در عملکرد محصولات یا خدماتی شود که از این APIهای استفاده می‌کنند. استفاده از نسخه‌دهی در URL می‌تواند از بروز چنین مشکلاتی جلوگیری کند. ([توضیحات بیشتر ...](https://apigee.com/about/blog/technology/restful-api-design-tips-versioning))

- پیام‌های پاسخ (Response) باید به‌خوبی توصیف‌کننده باشند، به‌طوری‌که گیرنده بتواند به‌راحتی مفهوم آن‌ها را درک کند. یک پیام خطای خوب می‌تواند به این شکل باشد:

```json
{
	"code": 1234,
	"message": "Something bad happened",
	"description": "More details"
}
```

یا برای خطاهای اعتبارسنجی:

```json
{
	"code": 2314,
	"message": "Validation Failed",
	"errors": [
		{
			"code": 1233,
			"field": "email",
			"message": "Invalid email"
		},
		{
			"code": 1234,
			"field": "password",
			"message": "No password provided"
		}
	]
}
```

_چرا:_

> توسعه‌دهندگان در زمان‌هایی که نیاز به عیب‌یابی و حل مشکلات دارند، به پیام‌های خطای طراحی‌شده و واضح متکی هستند. این پیام‌ها می‌توانند اطلاعات کافی برای رفع سریع مشکلات ارائه دهند.

_توجه: پیام‌های مربوط به خطای امنیتی را تا حد ممکن کلی و مبهم نگه دارید. به‌عنوان مثال، به جای گفتن «رمز عبور اشتباه است»، از عبارتی مثل «نام کاربری یا رمز عبور اشتباه است» استفاده کنید تا از افشای اطلاعات جزئی و ناخواسته جلوگیری کنید (در این صورت به کاربر اطلاع نداده‌اید که نام کاربری درست است و تنها رمز عبور اشتباه است)._

- از این کدهای وضعیت HTTP (Status Code) برای توصیف وضعیت پاسخ‌ها استفاده کنید تا نشان دهید آیا همه چیز درست انجام شده، خطایی از سمت کلاینت رخ داده، یا مشکلی در API وجود دارد:

_کدام یک:_

> کد `200 OK` برای نشان دادن موفقیت عملیات‌های `GET`، `PUT` یا `POST`

> کد `201 Created` برای مواقعی که یک نمونه جدید ساخته شده است (مثلاً پس از ایجاد منبع با متد `POST`، کد `201` برگردانید)

> کد `204 No Content` برای نشان دادن موفقیت عملیات اما بدون داشتن محتوای بازگشتی (مثلاً بعد از موفقیت در `DELETE`)

> کد `304 Not Modified` برای کاهش حجم انتقال داده زمانی که گیرنده قبلاً نسخه کش‌شده را دارد

> کد `400 Bad Request` برای زمانی که درخواست پردازش نشده است، زیرا سرور متوجه منظور کلاینت نشده است. (درخواست کلاینت قابل پردازش نیست.)

> کد `401 Unauthorized` برای زمانی که درخواست شامل اعتبارنامه (Credentials) معتبر نیست و باید با اعتبارنامه جدید تکرار شود

> کد `403 Forbidden` زمانی که سرور درخواست را می‌فهمد ولی از انجام آن امتناع می‌کند

> کد `404 Not Found` زمانی که منبع درخواستی پیدا نشود

> کد `500 Internal Server Error` نشان می‌دهد درخواست معتبر بوده اما سرور به‌دلیل شرایط پیش‌بینی‌نشده قادر به انجام آن نیست

_چرا:_

> اکثر ارائه‌دهندگان API از مجموعه محدودی از کدهای HTTP استفاده می‌کنند. برای مثال، API سرویس Google GData تنها از 10 کد وضعیت، Netflix از ۹ کد، و Digg تنها از 8 کد وضعیت استفاده می‌کنند. البته این پاسخ‌ها دربردارنده اطلاعات بیشتری در بدنه (Body) هستند. بیش از 70 کد وضعیت HTTP وجود دارد اما استفاده از کدهای وضعیت متداول باعث می‌شود توسعه‌دهندگان بدون نیاز به جستجوی اطلاعات اضافی، راحت‌تر با API کار کنند. ([توضیحات بیشتر ...](https://apigee.com/about/blog/technology/restful-api-design-what-about-errors))

- در پاسخ (Response)، تعداد کل منابع را اعلام کنید.

- پارامترهای `limit` و `offset` را برای کنترل اندازه پاسخ (Response) پشتیبانی کنید.

- توجه داشته باشید که ممکن است کاربر همیشه به نمایش کامل منبع نیاز نداشته باشد. برای محدود کردن فیلدهای موردنظر، از پارامتر `fields` استفاده کنید که مقادیر آن با کاما جدا می‌شوند:

```
GET /students?fields=id,name,age,class
```

- پیاده‌سازی قابلیت «صفحه‌بندی» (Pagination)، «فیلتر کردن» (Filtering) و «مرتب‌سازی» (Sorting) در ابتدای کار برای همه منابع ضروری نیست. اما منابعی که این قابلیت‌ها را دارند باید مستند (از طریق Document) شوند.

<a name="api-security"></a>

### 9.2 امنیت ای‌پی‌آی (API security)

این‌ها برخی از بهترین روش‌های امنیتی پایه هستند:

- از احراز هویت پایه (Basic Authentication) تنها در ارتباطات امن (HTTPS) استفاده کنید. توکن‌های احراز هویت (Authentication token) نباید در URL ارسال شوند:

```
GET /users/123?token=asdf....
```

_چرا:_

> اطلاعات احراز هویت مانند شناسه کاربری و رمز عبور و یا توکن، حتی اگر کدگذاری شده باشد (Base64)، به‌عنوان متن ساده قابل خواندن است (زیرا قابل بازگشایی است) و امنیت کافی ندارد. بنابراین، روش احراز هویت پایه (Basic Auth) ایمن نیست. ([توضیحات بیشتر ...](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication))

- توکن‌ها باید در هر درخواست، از طریق هدر Authorization ارسال شوند:

```bash
Authorization: Bearer xxxxxx, Extra yyyyy
```

- مدت اعتبار کد احراز هویت (Authorization Code) باید کوتاه باشد.

- هرگونه درخواست غیر ایمن (غیر TLS) را رد کرده و به آن پاسخ ندهید. به درخواست‌های HTTP با کد `403 Forbidden` پاسخ دهید تا از هرگونه تبادل ناامن جلوگیری کنید.

- محدودیت نرخ درخواست (Rate Limiting) را اعمال کنید.

_چرا:_

> برای محافظت از API در برابر ربات‌هایی که می‌توانند هزاران بار در ساعت درخواست ارسال کنند، بهتر است محدودیت نرخ درخواست‌ (Rate Limiting) را از همان ابتدای پیاده‌سازی مدنظر قرار دهید.

- هدرهای HTTP را به‌درستی تنظیم کنید تا امنیت وب‌اپلیکیشن شما افزایش یابد. ([اطلاعات بیشتر...](https://github.com/helmetjs/helmet))

- داده‌های دریافت‌شده را به فرم استاندارد تبدیل کنید یا در صورت خطا یا نامعتبر بودن، آن درخواست را با کد وضعیت `400 Bad Request` همراه با جزئیات خطا، رد کنید.

- تمام داده‌هایی که با REST API مبادله می‌شوند، باید توسط خود همان API اعتبارسنجی شوند.

- داده‌های JSON خود را سریال‌سازی (Serialize) کنید.

_چرا:_

> این کار از اجرای کدهای مخرب جاوااسکریپت که ممکن است از طریق داده‌های JSON ارسال شوند، جلوگیری می‌کند. در نتیجه بسیار مهم است که از سریالایزر معتبر JSON استفاده کنید تا مانع اجرای داده‌های ارسال‌شده از کاربر در مرورگر یا سرور شود.

- نوع محتوا (Content-Type) را اعتبارسنجی کنید و عموماً از `application/*json` استفاده کنید.

_چرا:_

> به‌عنوان مثال، اگر `application/x-www-form-urlencoded` را بپذیرید، مهاجم می‌تواند با ساخت یک فرم ساده، درخواست POST ارسال کند. سرور نباید نوع محتوای ارسالی را حدس بزند. در صورت فقدان یا نامعتبر بودن هدر Content-Type، سرور باید آن درخواست را با کد `4XX` رد کند.

- برای بررسی فهرست امنیتی APIها، به [API Security Checklist](https://github.com/shieldfy/API-Security-Checklist) مراجعه کنید.

<a name="api-documentation"></a>

### 9.3 مستندسازی ای‌پی‌آی/API documentation

- بخش `API Reference` را در [README.md template](./README.sample.md) برای API پر کنید.
- روش‌های احراز هویت API را با یک نمونه کد توضیح دهید.
- ساختار URL (فقط path بدون root URL) را به همراه نوع درخواست (Method) شرح دهید.

برای هر Endpoint، موارد زیر را توضیح دهید:

- اگر پارامترهای URL وجود دارند، آن‌ها را مطابق با نام ذکر شده در بخش URL مشخص کنید:

```
Required: id=[integer]
Optional: photo_id=[alphanumeric]
```

- اگر نوع درخواست POST است، نمونه‌های کاربردی ارائه دهید. قوانین پارامترهای URL در اینجا نیز اعمال می‌شوند. این بخش را به دو دسته اختیاری و الزامی تقسیم کنید.
- پاسخ موفقیت‌آمیز (Success Response)، کد وضعیت (Status Code) چه باید باشد و آیا داده‌ای در پاسخ بازگردانده می‌شود یا خیر؟ این اطلاعات زمانی مفید است که کاربران نیاز دارند بدانند چه چیزی از پاسخ دریافت خواهند کرد:

```
Code: 200
Content: { id : 12 }
```

- پاسخ خطا (Error Response)، بیشتر endpointها ممکن است به روش‌های مختلفی شکست بخورند. از دسترسی غیرمجاز گرفته تا پارامترهای اشتباه و غیره. تمامی این موارد باید در این بخش لیست شوند. ممکن است تکراری به نظر برسد، اما از ایجاد فرضیات جلوگیری می‌کند. به عنوان مثال:

```json
{
	"code": 401,
	"message": "Authentication failed",
	"description": "Invalid username or password"
}
```

- از ابزارهای طراحی API استفاده کنید؛ ابزارهای متن‌باز زیادی برای مستندسازی خوب وجود دارند، مانند [API Blueprint](https://apiblueprint.org/) و [Swagger](https://swagger.io/).

<a name="a11y"></a>

## 10. دسترس‌پذیری (Accessibility) ([a11y](https://www.a11yproject.com/))

<p align="right">
  <img src="/images/accessibility.png" alt="Accessibility" width="128" height="128">
</p>

### 10.1 پیاده‌سازی روش‌های دسترس‌پذیری

برای اطمینان از حفظ دسترس‌پذیری، از همان ابتدا این قوانین را در پروژه خود اعمال کنید:

_چرا:_

> محتوای وب [به‌طور پیش‌فرض دسترسی‌پذیر](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/HTML) است. این ویژگی زمانی به خطر می‌افتد که پیچیدگی‌های غیرضروری ایجاد شود. در نظر گرفتن دسترس‌پذیری از ابتدا بسیار آسان‌تر از تلاش برای بازبینی و اصلاح آن در مراحل بعدی است.

- با استفاده از ابزارهایی مانند [lighthouse](https://developers.google.com/web/tools/lighthouse#devtools) یا افزونه [axe DevTools](https://chrome.google.com/webstore/detail/axe-devtools-web-accessib/lhdoppojpmngadmnindnejefpokejbdd?hl=en-US) برنامه‌ریزی‌هایی جهت بررسی ادواری [دسترسی‌پذیری](https://web.dev/lighthouse-accessibility/) به طور منظم انجام دهید. بر اساس نیاز پروژه، اهداف و امتیازات حداقلی‌ای برای دسترس‌پذیری تعیین و توافق کنید و این امتیازات را بر اساس [تأثیر کاربر](https://github.com/dequelabs/axe-core/blob/develop/doc/rule-descriptions.md#wcag-21-level-a--aa-rules) ارزیابی کنید.

> **نکته:** برخی از [بررسی‌های ضروری](https://web.dev/lighthouse-accessibility/#additional-items-to-manually-check) باید به‌صورت دستی انجام شوند، مانند ترتیب منطقی تب‌ها. این ابزارها معمولاً این موارد را به‌عنوان تست‌های دستی فهرست می‌کنند. در axe باید نتایج بررسی خودکار را ذخیره کنید تا این موارد را مشاهده کنید.

- یک لینتر (Linter) مرتبط برای بررسی دسترس‌پذیری نصب کنید:
  - برای React: از [eslint-plugin-jsx-a11y](https://www.npmjs.com/package/eslint-plugin-jsx-a11y) استفاده کنید.
  - برای Angular: از [Angular Codelyzer](https://github.com/mgechev/codelyzer) بهره ببرید.
  - برای Vue: از [eslint-plugin-vuejs-accessibility](https://github.com/vue-a11y/eslint-plugin-vuejs-accessibility) استفاده کنید.

_چرا:_

> این افزونه‌ها به‌صورت خودکار بخشی از الزامات اولیه دسترس‌پذیری را کنترل می‌کنند و پیاده‌سازی آن‌ها ساده است.

- با استفاده از ابزارهایی مانند [axe-core](https://www.youtube.com/watch?v=-n5Ul7WPc3Y&list=PLMlWGnpsViOMt24a-Y_dybv68H-kj6Un6&t=1649s) یا مشابه آن، می‌توانید تست‌های دسترسی‌پذیری را راه‌اندازی و اجرا کنید.

- اگر از Storybook استفاده می‌کنید، دستورالعمل‌های [آن](https://storybook.js.org/blog/accessibility-testing-with-storybook/) را دنبال کنید.

_چرا:_

> این تست‌ها به شناسایی تغییراتی که ممکن است بر دسترس‌پذیری تأثیر منفی بگذارند کمک می‌کنند.

- از دیزاین سیستم‌های منطبق بر دسترسی‌پذیری مانند [React Spectrum](https://react-spectrum.adobe.com/react-spectrum/) یا [Material Design](https://material.io/design) بهره ببرید.

_چرا:_

> این کامپوننت‌ها به‌صورت پیش‌فرض از سطح بالایی از دسترس‌پذیری برخوردار هستند.

### 10.2 قوانین پایه دسترس‌پذیری

- از دسترس‌پذیر بودن نام لینک‌ها اطمینان حاصل کنید. از `aria-label` برای توصیف لینک‌ها استفاده کنید.

_چرا:_

> لینک‌های نامفهوم و غیرقابل دسترس می‌توانند برای دسترس‌پذیری موانعی ایجاد کنند.

- اطمینان حاصل کنید که لیست‌ها به‌درستی ساختاربندی شده باشند تا معتبر و قابل درک باشند.

_چرا:_

> لیست‌ها باید دارای عناصر والد و فرزند باشند تا معتبر و قابل درک باشند. صفحه‌خوان‌ها (Screen Readers) کمک می‌کند تا اطلاعات دقیق‌تری در مورد تعداد آیتم‌ها و ساختار لیست ارائه دهند.

- از رعایت ترتیب معنایی سرفصل‌ها (Heading Order) اطمینان حاصل کنید.

_چرا:_

> سرفصل‌ها ساختار کلی صفحه را منتقل می‌کنند. وقتی به‌درستی استفاده شوند، پیمایش در صفحه برای کاربر آسان‌تر می‌شود.

- از کُنتراست (تضاد رنگی) مناسب میان متن و پس‌زمینه اطمینان حاصل کنید.

_چرا:_

> افرادی که دچار ضعف بینایی هستند به کنتراست (تضاد رنگی) بالایی نیاز دارند تا بتوانند خطوط، حاشیه‌ها و جزئیات متن را به‌راحتی تشخیص دهند. اگر رنگ متن بیش از حد به رنگ پس‌زمینه نزدیک باشد، به سختی آن متن قابل خواندن خواهد بود.

- برای تصاویر، متن جایگزین کوتاه و توصیفی (Alt Text) ارائه دهید.

_چرا:_

> صفحه‌خوان‌ها قادر به تفسیر و توضیح تصاویر به کلمات خوانا نیستند؛ حتی اگر تصویر فقط حاوی متن باشد. بنابراین، متن جایگزین (Alt Text) به کاربران کمک می‌کند تا محتوای تصویر و هدف آن را درک کنند.

برای آشنایی بیشتر با دیگر قوانین دسترس‌پذیری می‌توانید به [این منبع](https://dequeuniversity.com/rules/axe) مراجعه کنید.

<a name="licensing"></a>

## 11. مجوزدهی/Licensing

<p align="right">
  <img src="/images/licensing.png" alt="Licensing" width="135" height="135">
</p>

اطمینان حاصل کنید که از منابعی استفاده می‌کنید که حق استفاده از آن‌ها را دارید. اگر از کتابخانه‌ها استفاده می‌کنید، به مجوزهای MIT، Apache یا BSD توجه کنید، اما اگر این کتابخانه‌ها را تغییر می‌دهید، حتماً جزئیات مجوز را بررسی کنید. استفاده از تصاویر و ویدئوهای دارای حق کپی‌رایت (Copyrighted) ممکن است مشکلات قانونی ایجاد کند.

---

منابع:
[RisingStack Engineering](https://blog.risingstack.com/),
[Mozilla Developer Network](https://developer.mozilla.org/),
[Heroku Dev Center](https://devcenter.heroku.com),
[Airbnb/javascript](https://github.com/airbnb/javascript),
[Atlassian Git tutorials](https://www.atlassian.com/git/tutorials),
[Apigee](https://apigee.com/about/blog),
[Wishtack](https://blog.wishtack.com)

Icons by [icons8](https://icons8.com/)
