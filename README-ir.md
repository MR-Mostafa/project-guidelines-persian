[中文版](./README-zh.md)
| [日本語版](./README-ja.md)
| [한국어](./README-ko.md)
| [Русский](./README-ru.md)
| [Português](./README-pt-BR.md)
| [Italiana](./README-it.md)
| [English](./README.md)
| [Persian/فارسی](./README-ir.md)

<p align="right">
  <a href="https://www.elsewhen.com/">
    <img src="./images/elsewhen-logo.png" width="180" height="180">
  </a>
</p>

# دستورالعمل‌های پروژه &middot; [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square)](http://makeapullrequest.com)

> وقتی که شروع و توسعه یک پروژه جدید برای شما شبیه به حرکت در یک میدان سبز و خالی (که هیچ ساختاری ندارد) است (استعاره از شروع کردن یک پروژه یا کار جدید از ابتدا و بدون هیچ محدودیت و ساختاری است)، نگهداری از آن می‌تواند کابوسی پیچیده و تاریک برای شخص دیگری باشد.
> در اینجا لیستی از دستورالعمل‌ها آمده است که ما آن‌ها را پیدا کرده‌ایم، نوشته‌ایم و گردآوری کرده‌ایم و فکر می‌کنیم که برای اکثر پروژه‌های جاوااسکریپت در [elsewhen](https://www.elsewhen.com) به خوبی عمل می‌کند.
> اگر می‌خواهید یک روش بهینه را به اشتراک بگذارید، یا فکر می‌کنید یکی از این دستورالعمل‌ها باید حذف شود، [با خیال راحت آن را با ما به اشتراک بگذارید](http://makeapullrequest.com).

<hr>

- [گیت (Git)](#git)
  - [برخی از قوانین Git](#some-git-rules)
  - [گردش کار گیت (Git Workflow)](#git-workflow)
  - [نگارش بهتر متن کامیت‌ها](#writing-good-commit-messages)
- [مستندات (Documentation)](#documentation)
- [متغیرهای محیطی (Environments)](#environments)
  - [ایجاد محیط‌های توسعه‌ی یکپارچه (Consistent Dev Environments)](#consistent-dev-environments)
  - [وابستگی‌های یکسان و هماهنگ (Consistent Dependencies)](#consistent-dependencies)
- [وابستگی‌ها (Dependencies)](#dependencies)
- [تست کردن/Testing](#testing)
- [ساختار و نام‌گذاری/Structure and Naming](#structure-and-naming)
- [سبک کدنویسی/Code style](#code-style)
  - [برخی از دستورالعمل‌های code style](#code-style-check)
  - [اعمال استانداردهای سبک کدنویسی](#enforcing-code-style-standards)
- [ثبت وقایع/Logging](#logging)
- [ای‌پی‌آی/API](#api)
  - [طراحی API](#api-design)
  - [امنیت ای‌پی‌آی/API security](#api-security)
  - [مستندسازی ای‌پی‌آی/API documentation](#api-documentation)
- [دسترس‌پذیری/Accessibility](#a11y)
- [مجوزدهی/Licensing](#licensing)

<a name="git"></a>

## 1. گیت (Git)

<p align="right">
  <img src="/images/branching.png" width="135" height="135">
</p>

<a name="some-git-rules"></a>

### 1.1 برخی از قوانین Git

در کار با Git، رعایت مجموعه‌ای از قوانین و اصول ضروری است که در ادامه به آن‌ها اشاره شده است:

- کار را در برنچ `feature` انجام دهید

_چرا:_

> کار بر روی برنچ‌ feature باعث می‌شود تمام تغییرات به صورت مجزا و در یک برنچ اختصاصی اعمال شوند. این روش به شما این امکان را می‌دهد که چندین Pull Request ارسال کنید بدون اینکه دچار سردرگمی شوید. همچنین، می‌توانید کد خود را مکرراً به‌روزرسانی کنید، بدون اینکه برنچ اصلی را با کدهای ناپایدار و ناتمام آلوده کنید. ([توضیحات بیشتر ...](https://www.atlassian.com/git/tutorials/comparing-workflows#feature-branch-workflow))

- از برنچ `develop` انشعاب بگیرید

_چرا:_

> با انشعاب از برنچ `develop،` می‌توانید مطمئن باشید که کد موجود در برنچ `master` همیشه پایدار و قابل `build` است و معمولاً می‌توان آن را مستقیماً برای انتشار/releases استفاده کرد (البته این رویکرد ممکن است برای برخی از پروژه‌ها بیش از حد یا فراتر از نیاز باشد).

- هرگز به برنچ `develop` یا `master` مستقیماً Push نکنید، بلکه یک درخواست Pull Request ایجاد کنید.

_چرا:_

> هرگز به برنچ‌های `develop` یا `master` مستقیماً Push نکنید. به جای آن، یک Pull Request ایجاد کنید. این کار به اعضای تیم اطلاع می‌دهد که یک feature تکمیل شده است و امکان بررسی کد توسط سایرین و بحث درباره تغییرات را فراهم می‌کند.

- قبل از Push کردن یک فیچر و ایجاد Pull Request، ابتدا برنچ `develop` محلی/local خود را به‌روزرسانی کنید و یک ری‌بیس (Rebase) تعاملی انجام دهید.

_چرا:_

> قبل از ارسال Pull Request، برنچ `develop` یا `master` محلی خود را به‌روزرسانی کرده و Rebase تعاملی انجام دهید. Rebase تغییرات محلی شما را به بالای تاریخچه انتقال می‌دهد و از ایجاد Commitهای غیرضروری جلوگیری می‌کند. این کار باعث تمیز و مرتب شدن تاریخچه Commitها می‌شود. ([توضیحات بیشتر ...](https://www.atlassian.com/git/tutorials/merging-vs-rebasing))

- تعارضات احتمالی را در حین `rebase` برطرف کنید و سپس Pull Request ایجاد کنید. (این کار به شفافیت و کیفیت کد کمک می‌کند.)

- برنچ‌های `feature` ایجاد شده، پس از اتمام کار و ادغام باید حذف شوند (در `local` و `remote`).

_چرا:_

> حذف برنچ‌های ادغام شده باعث می‌شود لیست برنچ‌ها شلوغ نشود و هر برنچ تنها یک بار به برنچ اصلی (`master` یا `develop`) ادغام شود. برنچ‌های `feature` فقط باید تا زمانی که کار هنوز در حال انجام است، وجود داشته باشند.

- قبل از ایجاد Pull Request، مطمئن شوید که برنچ `feature` شما به درستی `build` می‌شود و تمامی تست‌ها (از جمله بررسی سبک و استایل کدنویسی) موفقیت‌آمیز هستند.

_چرا:_

> زمانی‌که شما تصمیم دارید کد خود را به یک برنچ stable اضافه کنید، اگر تست‌های برنچ `feature` محلی/local ناموفق باشند، احتمال زیادی وجود دارد که `build` برنچ مقصد نیز با خطا مواجه شود. علاوه بر این، قبل از ایجاد درخواست Pull Request، ضروری است که بررسی سبک و استایل کدنویسی انجام گردد. زیرا این کار باعث بهبود خوانایی و استانداردسازی کد می‌شود و از شکست احتمالی `build` برنچ مقصد جلوگیری می‌کند.

- [از فایل](./.gitignore) `.gitignore` استفاده کنید.

_چرا:_

> فایل `.gitignore` فایل‌ها و دایرکتوری‌هایی که نباید به مخزن `remote` ارسال شوند (مانند فایل‌های سیستمی و تنظیمات ویرایشگرها) را مستثنی می‌کند. این کار از ارسال فایل‌های غیرضروری جلوگیری می‌کند.

- از برنچ‌های `develop` و `master` محافظت کنید.

_چرا:_

> این کار از برنچ‌های آماده برای production در برابر دریافت تغییرات غیرمنتظره و غیرقابل بازگشت محافظت می‌کند. توضیحات بیشتر را برای [GitHub](https://help.github.com/articles/about-protected-branches/), [Bitbucket](https://confluence.atlassian.com/bitbucketserver/using-branch-permissions-776639807.html) و [GitLab](https://docs.gitlab.com/ee/user/project/protected_branches.html) بخوانید.

<a name="git-workflow"></a>

### 1.2 گردش کار گیت (Git Workflow)

با توجه به دلایل اشاره‌شده، ما از روش [Feature Branch Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows#feature-branch-workflow) به همراه [Interactive Rebasing](https://www.atlassian.com/git/tutorials/merging-vs-rebasing#the-golden-rule-of-rebasing) و برخی عناصر [Gitflow](https://www.atlassian.com/git/tutorials/comparing-workflows#gitflow-workflow) (مانند نام‌گذاری شاخه‌ها و استفاده از برنچ `develop`) بهره می‌بریم. مراحل کلی آن به‌صورت زیر است:

- برای یک پروژه جدید، یک مخزن گیت (Git repository) را در پوشه پروژه ایجاد کنید. برای ویژگی‌ها یا تغییرات بعدی، دیگر نیازی به انجام این مرحله نیست.

```sh
cd <project directory>
git init
```

- یک شاخه جدید برای توسعه یک `feature` یا رفع یک `bug` ایجاد کنید و به آن سوئیچ کنید.

```sh
git checkout -b <branchname>
```

- اعمال تغییرات در فایل‌ها و ثبت آن‌ها

```sh
git add <file1> <file2> ...
git commit
```

_چرا:_

> با دستور `git add <file1> <file2> ...` باید تنها فایل‌هایی را اضافه کنید که یک تغییر کوچک و منسجمی را تشکیل می‌دهند.

> دستور `git commit` یک ویرایشگری را باز می‌کند که در آن می‌توانید متن کامیت خود را با جداسازی بخش موضوع (`subject`) از بدنه (`body`) بنویسید.

> در _بخش 1.3_ درباره‌ی آن توضیح بیشتری داده شده است.

_نکته:_

> می‌توانید به‌جای این دستور، از `git add -p` استفاده کنید تا تغییرات را به صورت مرحله‌به‌مرحله (hunk-by-hunk) بررسی کرده و تصمیم بگیرید کدام بخش در کامیت قرار بگیرد.

- برنچ لوکال خود را با مخزن `remote` همگام‌سازی کنید تا تغییرات جدید را دریافت کنید.

```sh
git checkout develop
git pull
```

_چرا:_

> این کار به شما این فرصت را می‌دهد که با conflictها در سیستم خود در حین rebasing و پیش از ارسال Pull Request مواجه شوید، به جای آنکه یک درخواست Pull Request ایجاد کنید که حاوی conflict و تضاد باشد.

- برنچ `feature` خود را با استفاده از interactive rebase با آخرین تغییرات از برنچ `develop`، به‌روزرسانی کنید.

```sh
git checkout <branchname>
git rebase -i --autosquash develop
```

_چرا:_

> با گزینه‌ی `--autosquash` می‌توانید تمام کامیت‌های خود را در برنچ `feature` در یک کامیت ترکیب کنید تا تاریخچه مرتب‌تری داشته باشید. زیرا هیچ‌کس تمایل ندارد برای یک ویژگی، چندین کامیت پراکنده در برنچ `develop` داشته باشد. ([توضیحات بیشتر ...](https://robots.thoughtbot.com/autosquashing-git-commits))

- اگر با conflictای مواجه شدید، [آن را برطرف کنید](https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/) و rebase را ادامه دهید، در غیر این صورت، می‌توانید این مرحله را نادیده بگیرید.

```sh
git add <file1> <file2> ...
git rebase --continue
```

- برنچ خود را پس از ری‌بیس `push` کنید. از آنجا که rebase تاریخچه‌ی برنچ را تغییر می‌دهد، Git جلوی Push عادی را می‌گیرد؛ بنابراین باید از `-f` برای اعمال اجباری تغییرات استفاده کنید. اگر افراد دیگری نیز روی برنچ شما کار می‌کنند، بهتر است از گزینه کمتر مخرب `--force-with-lease` استفاده کنید.

```sh
git push -f
```

_چرا:_

> وقتی که rebase انجام می‌دهید، گیت تاریخچه برنچ feature محلی را تغییر می‌دهید. در نتیجه، گیت جلوی Push عادی با استفاده از دستور `git push` را می‌گیرد. بنابراین باید از فلگ `-f` یا `--force` برای اعمال اجباری تغییرات استفاده کنید. ([توضیحات بیشتر ...](https://developer.atlassian.com/blog/2015/04/force-with-lease/))

- پس از Push کردن برنچ، یک Pull Request خود را ایجاد کنید.

- یک نفر از اعضای تیم یا مسئول بررسی کد، درخواست Pull Request را پس از بررسی، پذیرفته و آن را ادغام (Merge) کند، درنتیجه این درخواست بسته خواهد شد.

- در صورت اتمام کار،برنچ `feature` محلی خود را حذف کنید.

```sh
git branch -d <branchname>
```

جهت حذف تمام برنچ‌های محلی که دیگر در مخزن remote وجود ندارند، از دستور زیر استفاده کنید. (برای تمیز نگه‌داشتن محیط توسعه و حذف برنچ‌های قدیمی)

```sh
git fetch -p && for branch in `git branch -vv --no-color | grep ': gone]' | awk '{print $1}'`; do git branch -D $branch; done
```

<a name="writing-good-commit-messages"></a>

### 1.3 نگارش بهتر متن کامیت‌ها

داشتن راهنمای مناسب و پایبندی به آن برای نوشتن پیام‌های کامیت، همکاری با دیگران و نگهداری پروژه را بسیار ساده‌تر می‌کند. در اینجا چند قانون کلی وجود دارد ([منبع](https://chris.beams.io/posts/git-commit/#seven-rules)):

- موضوع (`subject`) را از بدنه (`body`) جدا کنید و بین این دو بخش یک خط خالی بگذارید.

_چرا:_

> گیت به اندازه کافی هوشمند است که خط اول پیام کامیت شما را به‌عنوان خلاصه تشخیص دهد. اگر به‌جای استفاده از `git log` از `git shortlog` استفاده کنید، فقط این خط اول (خلاصه) را به همراه شناسه کامیت خواهید دید.

- طول خط موضوع (`subject`) را تا 50 کاراکتر محدود نگه دارید و بدنه‌ی پیام (`body`) را حداکثر در 72 کاراکتر قرار دهید.

_چرا:_

> این کار باعث می‌شود کامیت‌ها تا حد ممکن متمرکز و خوانا باشند؛ نیازی به طولانی‌نویسی نیست. ([توضیحات بیشتر](https://medium.com/@preslavrachev/what-s-with-the-50-72-rule-8a906f61f09c))

- حرف اول موضوع (`subject`) را با عبارت بزرگ (Capitalize) شروع کنید.

- موضوع (`subject`) را با نقطه تمام نکنید.

- از [وجه امری](https://en.wikipedia.org/wiki/Imperative_mood) در موضوع (`subject`) استفاده کنید.

_چرا:_

> به جای نوشتن پیام‌هایی که فقط بیانگر یا توصیف‌کننده کاری هستند، بهتر است متن کامیت را به عنوان یک دستورالعمل‌ در نظر بگیرید تا مشخص کنند که پس از ادغام کامیت در مخزن، چه کاری قرار است انجام شود. ([توضیحات بیشتر ...](https://news.ycombinator.com/item?id=2079612))

- از قسمت بدنه (`body`) برای توضیح چرایی و چیستی کار انجام‌شده استفاده کنید، نه چگونگی انجام آن.

<a name="documentation"></a>

## 2. مستندات (Documentation)

<p align="right">
  <img src="/images/documentation.png" alt="Documentation" width="128" height="128">
</p>

- از این [ساختار](./README.sample.md) برای فایل `README.md` پروژه خود استفاده کنید؛ اگر بخش‌هایی وجود دارد که پوشش داده نشده است، می‌توانید آن‌ها را به‌دلخواه اضافه کنید.

- اگر پروژه‌تان چندین مخزن (repository) دارد، لینک هر مخزن را در فایل‌های `README.md` مربوطه درج کنید.

- با پیشرفت پروژه، فایل `README.md` را به‌روز نگه دارید تا همیشه منعکس‌کننده آخرین وضعیت باشد.

- برای درک بهتر بخش‌های اصلی کد، کد خود را کامنت‌گذاری کنید، همچنین سعی کنید که به‌وضوح توضیح دهید که قصد انجام چه کاری را دارید.

- اگر درباره کد یا روش مورد استفاده شما در گیت‌هاب یا استک‌اورفلو بحثی باز وجود دارد، لینک آن را در کامنت خود بگنجانید، تا سایر توسعه‌دهندگان بتوانند به بحث ایجاد شده دسترسی داشته باشند.

- کامنت‌ها نباید توجیهی برای کد ضعیف باشند. کد خود را تا حد امکان تمیز بنویسید.

- در عین حال از ارائه توضیحات تکمیلی در قالب کامنت، به این بهانه که کد تمیز می‌باشد، غافل نشوید.

- با پیشرفت کد، کامنت‌ها را هم به‌روز کنید تا با وضعیت فعلی پروژه همخوانی داشته باشند.

<a name="environments"></a>

## 3. متغیرهای محیطی (Environments)

<p align="right">
  <img src="/images/laptop.png" alt="Environments" width="128" height="128">
</p>

- در صورت نیاز، برای مراحل مختلف پروژه مانند `development`، `test` و `production،` محیط‌های جداگانه تعریف کنید.

_چرا:_

> هر محیط‌ (environment) مختلف ممکن است data، tokens، APIs، ports و... متفاوتی نیاز داشته باشند. به‌عنوان مثال، می‌توانید در حالت `development` از APIهای جعلی با داده‌های قابل پیش‌بینی استفاده کنید تا تست‌های دستی و خودکار ساده‌تر شوند. یا شاید بخواهید Google Analytics را فقط در محیط `production` فعال کنید و به همین ترتیب. ([توضیحات بیشتر ...](https://stackoverflow.com/questions/8332333/node-js-setting-up-environment-specific-configs-to-be-used-with-everyauth))

- پیکربندی‌های مختص هر محیط را به عنوان مقادیر ثابت در کد قرار ندهید، بلکه از متغیرهای محیطی (environment variables) برای جدا کردن پیکربندی هر محیط استفاده کنید ([به این نمونه نگاه کنید](./config.sample.js)).

_چرا:_

> متغیرهای محیطی ممکن است شامل توکن‌ها، رمزعبورها و سایر اطلاعات حساس باشند. قرار دادن این اطلاعات در کد باعث می‌شود در صورت عمومی شدن کد، این اطلاعات نیز فاش شوند.

_چگونه:_

> از فایل‌های `.env` برای ذخیره متغیرهای محیطی استفاده کنید و آن‌ها را در فایل `.gitignore` قرار دهید تا به مخزن remote ارسال نشوند. در عوض، یک فایل `.env.example` را کامیت کنید تا توسعه‌دهندگان دیگر از آن به‌عنوان راهنما استفاده کنند. برای محیط `production` همچنان به شیوه استاندارد متغیرهای محیطی را تنظیم کنید. ([توضیحات بیشتر](https://medium.com/@rafaelvidaurre/managing-environment-variables-in-node-js-2cb45a55195f))

- پیش از اجرای برنامه، متغیرهای محیطی را (مثلاً با استفاده از کتابخانه‌ای مانند `joi`) اعتبارسنجی کنید تا خطاهای احتمالی زودتر شناسایی شوند. ([نمونه](./configWithTest.sample.js))

_چرا:_

> این کار باعث می‌شود خطاهای احتمالی را زودتر شناسایی کنید و از هدررفتن ساعت‌ها مشکل‌یابی/troubleshooting توسط دیگران جلوگیری می‌کند.

> <a name="consistent-dev-environments"></a>

### 3.1 ایجاد محیط‌های توسعه‌ی یکپارچه (Consistent Dev Environments):

- نسخه‌ی Node را در بخش `engines` در فایل `package.json` وارد کنید.

_چرا:_

> در بخش `engines`، نسخه‌ی Node را مشخص کنید تا سایر توسعه‌دهندگان بدانند پروژه با کدام نسخه کار می‌کند. ([توضیحات بیشتر ...](https://docs.npmjs.com/files/package.json#engines))

- علاوه‌براین، از `nvm` استفاده کنید و یک فایل `.nvmrc` در ریشه‌ی پروژه ایجاد کنید و در مستندات به آن اشاره کنید.

_چرا:_

> تا هر کسی که از `nvm` استفاده می‌کند، بتواند به سادگی با اجرای `nvm use` بتواند به نسخه‌ی مناسب Node سوئیچ کند. ([توضیحات بیشتر ...](https://github.com/creationix/nvm))

- می‌توانید یک اسکریپت `preinstall` تنظیم کنید تا نسخه‌های Node و npm را بررسی کند.

_چرا:_

> زیرا برخی وابستگی‌ها (dependencies) ممکن است در صورت نصب توسط نسخه‌های جدیدتر npm دچار خطا شوند.

- در صورت امکان از Docker استفاده کنید.

_چرا:_

> این کار می‌تواند یک محیط سازگار در کل فرآیند کاری شما فراهم کند، بدون نیاز به تنظیمات یا وابستگی‌های پیچیده. ([توضیحات بیشتر …](https://hackernoon.com/how-to-dockerize-a-node-js-application-4fbab45a0c19))

- از پکیج‌های محلی (local) به‌جای پکیج‌های سراسری (globally) استفاده کنید.

_چرا:_

> این کار به شما اجازه می‌دهد پکیج‌های استفاده شده را با همکارانتان به اشتراک بگذارید، به جای آنکه انتظار داشته باشید آن‌ها به‌صورت سراسری روی سیستم خود نصب کرده باشند.

<a name="consistent-dependencies"></a>

### 3.2 وابستگی‌های یکسان و هماهنگ (Consistent Dependencies):

- اطمینان حاصل کنید که اعضای تیم دقیقاً همان وابستگی‌ها (dependencies) را مانند شما دریافت کنند.

_چرا:_

> برای اطمینان از این‌که پروژه در هر محیطی یکسان اجرا می‌شود و خطاهای پیش‌بینی‌نشده رخ ندهد. ([توضیحات بیشتر ...](https://kostasbariotis.com/consistent-dependencies-across-teams/))

_چگونه:_

> در نسخه‌های 5 یا بالاتر `npm`، از فایل `package-lock.json` استفاده کنید.

_اگر از `npm` قدیمی‌تر از نسخه 5 استفاده می‌کنید:_

> می‌توانید از `Yarn` بهره ببرید، مطمئن شوید در فایل `README.md` به این موضوع اشاره شده است. پس از هر به‌روزرسانی وابستگی‌ها، فایل lock file و فایل `package.json` باید با یکدیگر همخوانی داشته باشند. ([توضیحات بیشتر ...](https://yarnpkg.com/en/))

_اگر `Yarn` را نمی‌پسندید:_

> متأسفانه راه دیگری ندارید. در نسخه‌های قدیمی `npm`، هنگام نصب وابستگی جدید از `--save --save-exact` استفاده کنید و قبل از انتشار، فایل `npm-shrinkwrap.json` را بسازید. ([توضیحات بیشتر ...](https://docs.npmjs.com/files/package-locks))

<a name="dependencies"></a>

## 4. وابستگی‌ها (Dependencies)

<p align="right">
  <img src="/images/modules.png" alt="modules" width="128" height="128">
</p>

- پکیچ‌های نصب‌شده را ردیابی و نظارت کنید: به عنوان مثال، با اجرای دستور `npm ls --depth=0`، می‌توانید فهرست پکیج‌های سطح اول پروژه‌تان را مشاهده کنید و از وضعیت آن‌ها مطلع شوید. (این کار کمک می‌کند بدانید چه کتابخانه‌هایی در حال حاضر در پروژه نصب هستند و آیا همه آن‌ها مورد استفاده قرار می‌گیرند یا خیر.) ([توضیحات بیشتر ...](https://docs.npmjs.com/cli/ls))

- پکیج‌های بی‌استفاده یا نامربوط را با استفاده از ابزار depcheck شناسایی کنید. ([توضیحات بیشتر ...](https://www.npmjs.com/package/depcheck))

_چرا:_

> با استفاده از ابزار `depcheck` می‌توانید کتابخانه‌های غیرضروری را که تنها باعث افزایش حجم پروژه شده‌اند را بیابید و حذف کنید.

- قبل از استفاده از یک پکیچ، با بهره‌گیری از `npm-stat` می‌توانید میزان دانلود و محبوبیت یک پکیج را در جامعه برنامه‌نویسان بسنجید. ([توضیحات بیشتر ...](https://npm-stat.com/))

_چرا:_

> هرچه جامعه استفاده‌کنندگان بزرگ‌تر باشد، احتمال نگهداری بهتر و کشف سریع‌تر باگ‌ها بیشتر خواهد بود.

- پیش از افزودن یک وابستگی جدید، نسخه‌های منظم و فعال بودن تیم نگهدارنده (maintainers) را بررسی و ارزیابی کنید. به عنوان مثال، می‌توانید از دستور `npm view async` کمک بگیرید. ([توضیحات بیشتر ...](https://docs.npmjs.com/cli/view))

_چرا:_

> اگرچه تعداد بالا و فعالیت مداوم نگهدارندگان، می‌تواند روند رفع باگ‌ها و توسعه را تسهیل بکند، اما اگر مشارکت‌کنندگان نتوانند اصلاحات (`fixes`) و وصله‌ها (`patches`) را با سرعت کافی ادغام (`merge`) کنند، داشتن مشارکت‌کننده‌ی زیاد چندان مؤثر نخواهد بود.

- اگر قصد دارید از کتابخانه‌ای کمتر شناخته‌شده (غیرمشهور) استفاده کنید، ابتدا با اعضای تیم خود مشورت نمایید.

- همیشه از به‌روزبودن وابستگی‌ها با آخرین نسخه، اطمینان حاصل کنید. می‌توانید با اجرای دستور `npm outdated` وضعیت نسخه‌های فعلی پکیج‌ها را بررسی کنید. ([توضیحات بیشتر ...](https://docs.npmjs.com/cli/outdated))

_چرا:_

> پیش از بروزرسانی، حتماً Release Notes را مطالعه کرده و اگر تغییرات مخربی وجود دارد، آن‌ها را به‌صورت مرحله‌به‌مرحله اعمال کنید تا در صورت بروز مشکل، عیب‌یابی آسان‌تر باشد. ابزاری مانند [npm-check-updates](https://github.com/tjunnone/npm-check-updates) نیز در این زمینه مفید است.

- همواره پیش از اضافه کردن یا بروزرسانی یک پکیج، مشکلات امنیتی احتمالی آن را بررسی کنید. برای نمونه، [Snyk](https://snyk.io/test?utm_source=risingstack_blog) به شما گزارش‌های امنیتی مربوط به پکیج موردنظر را ارائه می‌دهد.

<a name="testing"></a>

## 5. تست کردن/Testing

<p align="right">
  <img src="/images/testing.png" alt="testing" width="128" height="128">
</p>

- در صورت نیاز، یک environment به نام `test` (برای حالت تست) ایجاد کنید.

_چرا:_

> گاهی تست end to end در حالت `production` ممکن است کافی به نظر برسد، اما در موارد خاص نیاز به محیط تست جداگانه‌ای وجود دارد. مثلاً ممکن است نخواهید اطلاعات تحلیلی در حالت `production` فعال شود و داشبورد افراد را با داده‌های تست آلوده کنید. (توضیحات مترجم: چون داده‌های تستی ممکن است اطلاعات واقعی را تحت تأثیر قرار دهد، مثلا باعث شلوغی و ایجاد داده‌های غیرضروری شوند و یا مانع از درک دقیق اطلاعات واقعی توسط کاربران یا تیم تحلیل شوند.) مثال دیگر این است که ممکن است API شما در حالت تولید محدودیت‌ تعداد درخواست (rate limit) داشته باشد و پس از تعداد مشخصی درخواست، فراخوانی APIها توسط تست را مسدود کند.

- فایل‌های تست خود را در کنار ماژول‌های مورد آزمایش با استفاده از الگوی نام‌گذاری خاصی `*.test.js` یا `*.spec.js` قرار دهید، مانند `moduleName.spec.js`.

_چرا:_

> برای پیدا کردن یک تست واحد، در ساختار پوشه‌ها جستجو و پیمایش نکنید. [توضیحات بیشتر ...](https://hackernoon.com/structure-your-javascript-code-for-testability-9bc93d9c72dc)

- برای جلوگیری از سردرگمی، فایل‌های تست اضافی خود را پر یک پوشه جداگانه قرار دهید.

_چرا:_

> برخی از فایل‌های تست مستقیماً به فایل پیاده‌سازی خاصی مرتبط نیستند. باید این فایل‌ها را در پوشه‌ای قرار دهید که احتمالاً توسط سایر توسعه‌دهندگان به راحتی یافت شود: پوشه `__test__`. این نام `__test__` هم اکنون یک استاندارد است و توسط اکثر فریم‌ورک‌های تست جاوااسکریپت تشخیص داده می‌شود.

- کد قابل تست بنویسید، از اثرات جانبی (side effect) خودداری کنید، اثرات جانبی را جدا کنید، و توابع خالص (pure functions) بنویسید.

_چرا:_

> هر بخش از منطق کسب‌وکار (business logic) باید به صورت مستقل و جداگانه مورد آزمایش و تست قرار گیرد تا مطمئن شوید که هر قسمت به درستی کار می‌کند. باید "تأثیر عوامل تصادفی یا فرآیندهای غیرقابل‌پیش‌بینی را در کد به حداقل برسانید" [توضیحات بیشتر ...](https://medium.com/javascript-scene/tdd-the-rite-way-53c9b46f45e3)

> یک تابع خالص (pure function) تابعی است که همیشه برای ورودی یکسان، خروجی یکسانی را باز می‌گرداند. برعکس، یک تابع ناخالص (impure function) تابعی است که ممکن است اثرات جانبی داشته باشد یا برای تولید یک مقدار به شرایط خارجی وابسته باشد، که این امر باعث می‌شود کمتر قابل پیش‌بینی باشد. [توضیحات بیشتر ...](https://hackernoon.com/structure-your-javascript-code-for-testability-9bc93d9c72dc)

- از یک static type checker استفاده کنید

_چرا:_

> گاهی ممکن است به یک Static type checker نیاز داشته باشید. این ابزارها، سطحی از قابلیت اطمینان را برای کد شما به ارمغان می‌آورند. [توضیحات بیشتر ...](https://medium.freecodecamp.org/why-use-static-types-in-javascript-part-1-8382da1e0adb)

- قبل از آنکه درخواست pull request به برنچ `develop` را ارسال کنید، تست‌ها را به‌صورت locally اجرا کنید.

_چرا:_

> قطعاً نمی‌خواهید کسی باشید که باعث شکست فرایند بیلد برنچ آماده‌ی production شده است. تست‌های خود را پس از `rebase` و پیش از ارسال به شاخه feature-branch به مخزن ریموت اجرا کنید.

- تست‌های خود را از جمله دستورالعمل‌های مربوطه در بخش مناسب فایل `README.md` پروژه را مستندسازی کنید.

_چرا:_

> این مستندات مانند یک یادداشت راهنما است که برای توسعه‌دهندگان دیگر، کارشناسان DevOps، یا تیم تضمین کیفیت (QA) و هر کسی که با کد شما کار می‌کند، مفید خواهد بود.

<a name="structure-and-naming"></a>

## 6. ساختار و نام‌گذاری/Structure and Naming

<p align="right">
  <img src="/images/folder-tree.png" alt="Structure and Naming" width="128" height="128">
</p>

- فایل‌های خود را بر اساس ویژگی‌های محصول / صفحات / کامپوننت‌ها سازمان‌دهی کنید، نه بر اساس نقش‌ها. همچنین فایل‌های تست را در کنار آن‌ها قرار دهید.

**بد**

```
.
├── controllers
|   ├── product.js
|   └── user.js
├── models
|   ├── product.js
|   └── user.js
```

**خوب**

```
.
├── product
|   ├── index.js
|   ├── product.js
|   └── product.test.js
├── user
|   ├── index.js
|   ├── user.js
|   └── user.test.js
```

_چرا:_

> به جای داشتن لیست طولانی از فایل‌ها، ماژول‌های کوچک ایجاد کنید که هر کدام یک مسئولیت خاص را دربرمی‌گیرند، از جمله تست آن‌ها و موارد دیگر. این کار باعث می‌شود دسترسی به فایل‌ها ساده‌تر شده و بتوانید به سرعت و با یک نگاه فایل‌های مورد نظر را پیدا کنید.

- فایل‌های تست اضافی خود را در یک پوشه‌ی جداگانه به نام test قرار دهید تا از سردرگمی جلوگیری شود.

_چرا:_

> این کار برای سایر توسعه‌دهندگان یا کارشناسان DevOps تیم شما موجب صرفه‌جویی در زمان می‌شود.

- از یک پوشه به نام `./config` برای تنظیمات استفاده کنید و فایل‌های پیکربندی جداگانه برای محیط‌ها (environments) مختلف ایجاد نکنید.

_چرا:_

> زمانی که یک فایل کانفیگ را برای اهداف مختلف (مانند پایگاه داده، API و غیره) تجزیه می‌کنید، قرار دادن آن‌ها در پوشه‌ای با نام مشخص مانند `config` منطقی است. فقط به خاطر داشته باشید که برای محیط‌های مختلف فایل‌های جداگانه نسازید، زیرا با افزایش استقرارهای برنامه، نام‌های محیط جدیدی مورد نیاز می‌شود و مدیریت آن پیچیده خواهد شد.

> مقادیر مورد استفاده در فایل‌های کانفیگ باید از طریق متغیرهای محیطی (environment variables) فراهم شوند. [توضیحات بیشتر ...](https://medium.com/@fedorHK/no-config-b3f1171eecd5)

- اسکریپت‌های خود را در یک پوشه به نام `./scripts` قرار دهید. این شامل اسکریپت‌های `bash` و `node` است.

_چرا:_

> احتمالاً به بیش از یک اسکریپت نیاز خواهید داشت، مانند production build, development build, database feeders, database synchronization و غیره.

- خروجی بیلد خود را در یک پوشه به نام `./build` قرار دهید. `build/` را به `.gitignore` اضافه کنید.

_چرا:_

> نام‌گذاری آن به سلیقه شما بستگی دارد، `dist` نیز گزینه خوبی است. اما با تیم خود این نام‌گذاری را هماهنگ کنید. فایل‌هایی که در این پوشه قرار می‌گیرند معمولاً تولید شده‌اند (bundled, compiled, transpiled) یا به این پوشه منتقل شده‌اند. چیزی که می‌توانید تولید کنید، هم‌تیمی‌های شما نیز باید قادر به تولید آن باشند؛ بنابراین نیازی به ارسال آن‌ها به مخزن ریموت نیست، مگر اینکه هدف خاصی داشته باشید.

<a name="code-style"></a>

## 7. سبک کدنویسی/Code style

<p align="right">
  <img src="/images/code-style.png" alt="Code style" width="128" height="128">
</p>

<a name="code-style-check"></a>

### 7.1 برخی از اصول code style

- برای پروژه‌های جدید از سینتکس جاوااسکریپت مدرن (استیج ۲ و بالاتر) استفاده کنید. برای پروژه‌های قدیمی، با سینتکس موجود سازگار بمانید مگر اینکه قصد به‌روزرسانی آن را داشته باشید.

_چرا:_

> این موضوع به تصمیم شما بستگی دارد. ما از مبدل‌ها (ترنسپایلرها) برای بهره‌گیری از مزایای سینتکس جدید استفاده می‌کنیم. استیج ۲ با تغییرات جزئی احتمالا بخشی از استاندارد خواهد شد.

- اطمینان حاصل کنید که بررسی سبک کدنویسی (code style) به عنوان بخشی از فرآیند build پروژه انجام شود. (تا هماهنگی و استاندارد بودن کدها در تمام مراحل توسعه حفظ شود.)

_چرا:_

> متوقف کردن build برنامه یکی از روش‌های اعمال سبک کدنویسی در کد است. این کار از بی‌توجهی به سبک کدنویسی جلوگیری می‌کند. این روش را برای کد سمت client و server اجرا کنید. [توضیحات بیشتر ...](https://www.robinwieruch.de/react-eslint-webpack-babel/)

- برای اعمال سبک کدنویسی از [ESLint - ابزار بررسی سبک کدنویسی جاوااسکریپت](http://eslint.org/) استفاده کنید.

_چرا:_

> ما `eslint` را ترجیح می‌دهیم، اما شما می‌توانید انتخاب دیگری داشته باشید. این ابزار قوانین بیشتری را پشتیبانی می‌کند، همچنین قابلیت تنظیم و افزودن قوانین سفارشی را دارد.

- ما از کد استایل [Airbnb](https://github.com/airbnb/javascript) برای جاوااسکریپت استفاده می‌کنیم، [بیشتر بخوانید](https://www.gitbook.com/book/duk/airbnb-javascript-guidelines/details). از کد استایلی که پروژه یا تیم شما نیاز دارد استفاده کنید (تا کدهایتان با استانداردهای تعیین‌شده هماهنگ باشند).
- ما هنگام استفاده از [FlowType](https://flow.org/) از [قوانین بررسی سبک تایپ Flow برای ESLint](https://github.com/gajus/eslint-plugin-flowtype) استفاده می‌کنیم.

_چرا:_

> ابزار Flow سینتکس‌های جدیدی را معرفی می‌کند که نیاز به رعایت سبک کدنویسی خاصی دارند و باید بررسی شوند.

- از فایل `.eslintignore` برای مستثنی کردن فایل‌ها یا پوشه‌ها از بررسی کد استایل استفاده کنید.

_چرا:_

> برای مستثنی کردن چند فایل از بررسی سبک کدنویسی، لازم نیست کدتان را با کامنت‌های `eslint-disable` شلوغ کنید.

- قبل از ارسال یک Pull Request، تمام کامنت‌های `eslint-disable` خود را حذف کنید.

_چرا:_

> طبیعی است که هنگام کار بر روی یک بخش از کد، برای تمرکز بیشتر روی منطق، بررسی سبک را غیرفعال کنید. فقط به خاطر داشته باشید که کامنت‌های `eslint-disable` را حذف کرده و قوانین را رعایت کنید.

- بسته به حجم و اندازه کار، از کامنت‌های `//TODO:` استفاده کنید یا یک تیکت باز کنید.

_چرا:_

> استفاده از کامنت‌های `//TODO:` به شما و همکارانتان کمک می‌کند تا وظایف کوچک مانند بازنویسی یک تابع یا به‌روزرسانی یک توضیح را به خاطر بسپارید. برای وظایف بزرگ‌تر، از فرمت `//TODO(#3456)` استفاده کنید که توسط قوانین lint اعمال می‌شود، که شماره‌ی داخل پرانتز به یک تیکت باز اشاره دارد.

- همیشه کامنت‌ها را به‌روز و مرتبط با تغییرات کد نگه دارید. بخش‌های کامنت‌شده کد را حذف کنید.

_چرا:_

> کد شما باید تا حد ممکن خوانا باشد؛ هر چیزی که حواس را پرت می‌کند، حذف کنید. اگر یک تابع را بازنویسی کردید، تابع قدیمی را فقط کامنت نکنید، بلکه آن را حذف کنید.

- از کامنت‌ها، لاگ‌ها یا نام‌های نامرتبط یا طنزآمیز پرهیز کنید.

_چرا:_

> اگرچه در فرآیند build برنامه آن‌ شوخی‌ها ممکن است (و بهتر است بگویم باید) حذف شود، اما گاهی source code شما به شرکت یا مشتری دیگری منتقل می‌شود که ممکن است آن‌ها چنین شوخی‌هایی را نپسندند.

- نام‌ها را به گونه‌ای انتخاب کنید که قابل جست‌وجو و دارای تفاوت‌های معنادار باشند و از نام‌های کوتاه‌شده و مخفف بپرهیزید. برای توابع، از نام‌های طولانی و توصیفی استفاده کنید. نام تابع باید یک فعل یا عبارت فعلی باشد و هدف آن را به وضوح بیان کند.

_چرا:_

> این کار (استفاده از نام‌های کامل و توصیفی) باعث می‌شود کد خواناتر و درک آن راحت‌تر و ساده‌تر شود.

- توابع خود را در فایل بر اساس «قانون نزولی» (Step-down Rule) سازمان‌دهی کنید؛ به این صورت که توابع سطح بالاتر در بالای فایل و توابع سطح پایین‌تر در زیر آن‌ها قرار گیرند.

_چرا:_

> این کار کد را خواناتر و درک آن بهتر می‌کند

<a name="enforcing-code-style-standards"></a>

### 7.2 اعمال استانداردهای سبک کدنویسی

- از فایل [.editorconfig](http://editorconfig.org/) استفاده کنید که به توسعه‌دهندگان کمک می‌کند تا سبک‌های کدنویسی یکسانی را بین ویرایشگرها و IDEهای مختلف پروژه تعریف و حفظ کنند.

_چرا:_

> پروژه EditorConfig شامل یک فرمت فایل برای تعریف سبک‌ و استال‌های کدنویسی است که شامل مجموعه‌ای از افزونه‌ها برای ویرایشگرهای متنی است، که به ویرایشگرها این امکان را می‌دهد تا فرمت فایل را بخوانند و از استایل‌های تعریف‌شده پیروی کنند. فایل‌های EditorConfig خوانا هستند و به‌خوبی با سیستم‌های کنترل نسخه کار می‌کنند.

- ویرایشگر خود را طوری تنظیم کنید که به شما در مورد خطاهای سبک کدنویسی اطلاع دهد. از [eslint-plugin-prettier](https://github.com/prettier/eslint-plugin-prettier) و [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier) همراه با پیکربندی ESLint خود استفاده کنید. [توضیحات بیشتر ...](https://github.com/prettier/eslint-config-prettier#installation)
- استفاده از Git hooks را مدنظر قرار دهید.

_چرا:_

> استفاده از Git hooks به‌طور قابل‌توجهی بهره‌وری توسعه‌دهندگان را افزایش می‌دهد. با اعمال تغییرات، انجام commit و ارسال (push) به محیط‌های staging یا production، بدون نگرانی از خراب شدن build برنامه، می‌توانید با اطمینان بیشتری کار کنید. [توضیحات بیشتر ...](http://githooks.com/)

- از Prettier همراه با یک precommit hook استفاده کنید.

_چرا:_

> اگرچه `prettier` به‌خودی‌خود قدرتمند است، اجرای دستی آن به‌عنوان یک تسک npm برای قالب‌بندی کد چندان کارآمد نیست. در اینجا `lint-staged` (و `husky`) وارد عمل می‌شوند. درباره پیکربندی `lint-staged` [اینجا](https://github.com/okonet/lint-staged#configuration) و پیکربندی `husky` [اینجا](https://github.com/typicode/husky) بیشتر بخوانید..

<a name="logging"></a>

## 8. ثبت وقایع/Logging

<p align="right">
  <img src="/images/logging.png" alt="Logging" width="128" height="128">
</p>

- از استفاده از console.log در سمت کلاینت در محیط production خودداری کنید.

_چرا:_

> حتی اگر فرآیند build برنامه شما می‌تواند (و باید) آن‌ لاگ‌ها را حذف کند، اطمینان حاصل کنید که ابزار بررسی استایل کدنویسی شما درباره‌ی باقی‌مانده‌های console.log هشدار می‌دهد.

- برای تولید لاگ‌های خوانا در محیط production، بهتر است از کتابخانه‌های logging مناسب (مانند [winston](https://github.com/winstonjs/winston) یا [node-bunyan](https://github.com/trentm/node-bunyan)) استفاده کنید.

_چرا:_

> این کار عیب‌یابی را آسان‌تر و دلپذیرتر می‌کند، چون می‌توانید از قابلیت‌هایی مانند رنگ‌بندی، افزودن زمان به لاگ‌ها، ثبت لاگ‌ها در فایل علاوه بر کنسول و حتی ثبت لاگ‌ها در فایل‌هایی که به‌صورت روزانه ایجاد و بایگانی می‌شوند، استفاده کنید. [توضیحات بیشتر ...](https://blog.risingstack.com/node-js-logging-tutorial/)

<a name="api"></a>

## 9. ای‌پی‌آی/API

<a name="api-design"></a>

<p align="right">
  <img src="/images/api.png" alt="API" width="128" height="128">
</p>

### 9.1 طراحی API

_چرا:_

> هدف این است که رابط‌های RESTfulی طراحی کنیم که منطقی و ساده باشند تا اعضای تیم و مشتریان بتوانند به‌سادگی و به‌صورت یکنواخت از آن‌ها استفاده کنند.

_چرا:_

> نبود هماهنگی و سادگی می‌تواند هزینه‌های یکپارچه‌سازی و نگهداری را به طور چشمگیری افزایش دهد؛ به همین دلیل طراحی `API` در این داکیومنت گنجانده شده است.

- ما عمدتاً از طراحی مبتنی بر منابع (Resource-Oriented Design) پیروی می‌کنیم که سه عنصر اصلی دارد: منابع (Resource)، مجموعه‌ها (Collection) و URLها.
  - یک منبع شامل داده‌هایی است که می‌تواند به صورت تو در تو (nested) سازمان‌دهی شود و متدهایی برای عملیات روی آن وجود دارد.
  - گروهی از منابع، یک مجموعه نامیده می‌شود.
  - آدرس اینترنتی (URL) که مکان آنلاین یک منبع یا مجموعه را مشخص می‌کند.

_چرا:_

> این یک طراحی بسیار شناخته‌شده برای توسعه‌دهندگان است (که اصلی‌ترین مصرف‌کنندگان API هستند). علاوه بر خوانایی و سهولت استفاده، این روش به ما اجازه می‌دهد کتابخانه‌ها و connectorهای عمومی بنویسیم بدون این‌که نیاز به شناخت جزئیات خاص هر API داشته باشیم.

- برای URL‌ها از kebab-case استفاده کنید.
- برای پارامترهای query string یا فیلدهای منابع از camelCase استفاده کنید.
- از اسامی جمع به صورت kebab-case برای نام منابع در URLها استفاده کنید.
- همیشه از اسامی جمع برای نامگذاری URLهایی که به یک مجموعه اشاره دارند استفاده کنید: `/users`.

_چرا:_

> اساساً، این کار خوانایی را بهتر کرده و URLها را هماهنگ نگه می‌دارد. [توضیحات بیشتر ...](https://apigee.com/about/blog/technology/restful-api-design-plural-nouns-and-concrete-names)

- در سورس کد، اسامی جمع را به متغیرها و پراپرتی‌ها با پسوند «List» تبدیل کنید.

_چرا:_:

> استفاده از اسامی جمع در URL مناسب است، اما در سورس کد ممکن است نامحسوس و مستعد خطا باشد.

- همیشه از مفاهیم مفرد استفاده کنید که با یک مجموعه شروع شده و به یک شناسه ختم می‌شوند:

```
/students/245743
/airports/kjfk
```

- از تولید URLهایی مانند زیر اجتناب کنید:

```
GET /blogs/:blogId/posts/:postId/summary
```

_چرا:_

> این URL به جای ارجاع به یک منبع (resource)، به یک ویژگی (property) اشاره می‌کند. شما می‌توانید ویژگی مورد نظر را به‌عنوان یک پارامتر در درخواست ارسال کنید تا پاسخ دریافتی مختصرتر و بهینه‌تر باشد.

- افعال را از URLهای منابع خود حذف کنید.

_چرا:_

> زیرا اگر برای هر عملیات resource از یک فعل استفاده کنید، به زودی با لیستی بزرگ از URLها مواجه خواهید شد که الگوی ثابتی ندارند و یادگیری را برای توسعه‌دهندگان دشوار می‌کنند. علاوه بر این، ما از افعال برای چیز دیگری استفاده می‌کنیم.

- از افعال برای موارد غیر منبع (non-resources) استفاده کنید. در این حالت، API شما هیچ منبعی برنمی‌گرداند. در عوض، یک عملیات را اجرا کرده و نتیجه را برمی‌گرداند. این‌ها عملیات CRUD (ایجاد، بازیابی، به‌روزرسانی و حذف) **نیستند**:

```
/translate?text=Hallo
```

_چرا:_

> زیرا برای CRUD ما از متدهای HTTP بر روی URLهای `resource` یا `collection` استفاده می‌کنیم. افعالی که درباره آن‌ها صحبت می‌کنیم در واقع کنترلرها `Controllers` هستند. شما معمولاً تعداد زیادی از این‌ها را توسعه نمی‌دهید. [توضیحات بیشتر ...](https://github.com/byrondover/api-guidelines/blob/master/Guidelines.md#controller)

- اگر بدنه درخواست (request body) یا پاسخ (response) از نوع `JSON` است، لطفاً برای نام‌گذاری پراپرتی‌های JSON از `camelCase` پیروی کنید تا یکپارچگی و سازگاری حفظ شود.

_چرا:_

> این یک راهنما و دستورالعمل برای پروژه JavaScript است، که فرض بر این است که زبان برنامه‌نویسی مورد استفاده برای تولید و تجزیه JSON، جاوااسکریپت می‌باشد.

- با وجود اینکه یک منبع (resource) مفهومی یکتا و مفرد است که مشابه با یک نمونه شیء یا رکورد پایگاه داده است، شما نباید از نام جدول (`table_name`) برای نام‌گذاری منبع و از نام ستون (`column_name`) برای پراپرتی‌های منبع استفاده کنید. به عبارت دیگر، نام‌گذاری منابع و پراپرتی‌های آن‌ها نباید مستقیماً از ساختار پایگاه داده مشتق شود؛ بلکه باید بر اساس مفاهیم و نیازهای دامنه‌ی کاربرد طراحی شود تا از وابستگی به جزئیات پیاده‌سازی جلوگیری شود.

_چرا:_

> زیرا هدف شما نمایش منابع است، نه جزئیات ساختار پایگاه داده.

- دوباره تکرار می‌کنم، فقط از اسم‌ها در URL خود هنگام نام‌گذاری منابع استفاده کنید و سعی نکنید عملکرد آن‌ها را توضیح دهید.

_چرا:_

> فقط از اسامی در URLهای منبع استفاده کنید و از نوشتن مواردی مانند `/addNewUser` یا `/updateUser` خودداری کنید. همچنین از ارسال عملیات منابع به‌عنوان پارامتر اجتناب کنید.

- عملکردهای CRUD را با استفاده از متدهای HTTP توضیح دهید:

_چگونه:_

> متد `GET`: برای دریافت از یک resource استفاده می‌شود.

> متد `POST`: برای ایجاد منابع (resources) جدید و زیرمنابع (sub-resources) به کار می‌رود.

> متد `PUT`: برای به‌روزرسانی منابع موجود استفاده می‌شود.

> متد `PATCH`: برای به‌روزرسانی جزئی منابع موجود به کار می‌رود؛ به‌طوری‌که فقط فیلدهای ارائه‌شده را به‌روزرسانی کرده و سایر فیلدها را بدون تغییر باقی می‌گذارد.

> متد `DELETE`: برای حذف منابع موجود استفاده می‌شود.

- برای منابع تو در تو (Nested Resources)، توصیه می‌شود رابطه بین آن‌ها را در ساختار URL منعکس کنید. به‌عنوان مثال، برای نمایش ارتباط بین یک کارمند و شرکت مربوطه، می‌توانید از شناسه‌ها (`id`) در URL استفاده کنید.

_چرا:_

> این روش دسترسی به منابع مرتبط را آسان‌تر می‌کند.

_چگونه:_

> درخواست `GET /schools/2/students` , باید لیست تمام دانش‌آموزان مدرسه با شناسه ۲ را برگرداند.

> درخواست `GET /schools/2/students/31` , باید جزئیات دانش‌آموز با شناسه ۳۱ را که متعلق به مدرسه ۲ است، برگرداند.

> درخواست `DELETE /schools/2/students/31` , باید دانش‌آموز با شناسه ۳۱ را که متعلق به مدرسه ۲ است، حذف کند.

> درخواست `PUT /schools/2/students/31` , باید اطلاعات دانش‌آموز با شناسه ۳۱ را که متعلق به مدرسه ۲ است، به‌روزرسانی کند.

> درخواست `POST /schools` , باید یک مدرسه جدید ایجاد کرده و جزئیات مدرسه تازه ایجاد شده را برگرداند. از POST بر روی URLهای مجموعه‌ای (Collection) استفاده کنید.

- برای نسخه‌دهی، از یک شماره ترتیبی ساده با پیشوند `v` استفاده کنید (مانند v1، v2) و آن را تا حد امکان در ابتدای URL قرار دهید تا دامنه بالاتری را (برای تاثیرگذاری) داشته باشد:

```
http://api.domain.com/v1/schools/3/students
```

_چرا:_

> وقتی APIهای شما به‌طور عمومی برای سایر اشخاص ثالث در دسترس هستند، اعمال تغییرات ناسازگار (breaking changes)، می‌تواند باعث اختلال در عملکرد محصولات یا خدماتی شود که از APIهای شما استفاده می‌کنند. استفاده از نسخه‌بندی در URL می‌تواند از بروز چنین مشکلاتی جلوگیری کند. [توضیحات بیشتر ...](https://apigee.com/about/blog/technology/restful-api-design-tips-versioning)

- پیام‌های پاسخ (Response) باید خودتوضیح‌دهنده باشند، به‌طوری‌که گیرنده بتواند به‌راحتی مفهوم آن‌ها را درک کند. یک پیام خطای مناسب ممکن است شبیه به این باشد:

```json
{
	"code": 1234,
	"message": "Something bad happened",
	"description": "More details"
}
```

یا برای خطاهای اعتبارسنجی:

```json
{
	"code": 2314,
	"message": "Validation Failed",
	"errors": [
		{
			"code": 1233,
			"field": "email",
			"message": "Invalid email"
		},
		{
			"code": 1234,
			"field": "password",
			"message": "No password provided"
		}
	]
}
```

_چرا:_

> توسعه‌دهندگان در زمان‌های بحرانی که در حال عیب‌یابی و حل مشکلات پس از انتشار برنامه‌هایی که با استفاده از APIهای شما ساخته‌اند و در دست کاربران قرار گرفته‌اند، به خطاهای خوب و خوش‌طراحی‌شده وابسته هستند.

_توجه: پیام‌های استثنا مربوط به امنیت را تا حد ممکن عمومی و ساده نگه دارید. به عنوان مثال، به جای اینکه بنویسید «رمز عبور اشتباه است»، می‌توانید پیام «نام کاربری یا رمز عبور نامعتبر است» را بازگردانید. این کار باعث می‌شود که به‌طور ناخودآگاه به کاربر اطلاع ندهید که نام کاربری درست است و تنها رمز عبور اشتباه است._

- از این کدهای وضعیت (status codes) برای ارسال همراه با پاسخ‌های خود استفاده کنید تا مشخص کنید آیا **همه چیز درست انجام شده است یا خیر**، آیا **کلاینت اشتباهی انجام داده** یا **مشکل از API بوده است**.

      _کدام یک:_
      > پاسخ `200 OK` نشان‌دهنده موفقیت برای درخواست‌های `GET`, `PUT` یا `POST` است.

      > کد `201 Created` برای زمانی است که یک نمونه جدید ایجاد می‌شود. ایجاد یک نمونه جدید با استفاده از متد `POST` کد وضعیت `201` را برمی‌گرداند.

      > پاسخ `204 No Content` نشان‌دهنده موفقیت است، اما محتوایی برای ارسال در پاسخ وجود ندارد. از آن در زمانی استفاده کنید که عملیات `DELETE` با موفقیت انجام شده است.

      > پاسخ `304 Not Modified` برای به حداقل رساندن انتقال اطلاعات زمانی که گیرنده قبلاً نسخه‌های کش‌شده را دارد، استفاده می‌شود.

      > کد `400 Bad Request` برای زمانی است که درخواست پردازش نشده است، زیرا سرور نمی‌تواند بفهمد که مشتری چه چیزی درخواست کرده است.

      > کد `401 Unauthorized` برای زمانی است که درخواست فاقد اعتبارنامه‌های معتبر است و باید با اعتبارنامه‌های مورد نیاز دوباره ارسال شود.

      > کد `403 Forbidden` به این معنی است که سرور درخواست را فهمیده است، اما از اعطای مجوز خودداری می‌کند.

      > کد `404 Not Found` نشان می‌دهد که منبع درخواستی پیدا نشده است.

      > کد `500 Internal Server Error` نشان می‌دهد که درخواست معتبر است، اما سرور به دلیل برخی شرایط غیرمنتظره نمی‌تواند آن را انجام دهد.

      _چرا:_
      > بیشتر ارائه‌دهندگان API از تعداد کمی از کدهای وضعیت HTTP استفاده می‌کنند. برای مثال، API سرویس Google GData تنها از ۱۰ کد وضعیت، Netflix از ۹ کد، و Digg تنها از ۸ کد وضعیت استفاده می‌کنند. البته، این پاسخ‌ها معمولاً شامل بدنه‌ای هستند که اطلاعات بیشتری را ارائه می‌دهد. در کل، بیش از ۷۰ کد وضعیت HTTP وجود دارد. اما اکثر توسعه‌دهندگان همه این ۷۰ کد را به خاطر ندارند.بنابراین، اگر شما کدهای وضعیتی را انتخاب کنید که خیلی رایج نیستند، توسعه‌دهندگان مجبور می‌شوند به جای ادامه کار روی برنامه خود، وقتشان را صرف جستجو در ویکی‌پدیا کنند تا متوجه شوند شما چه چیزی را سعی دارید به آن‌ها بگویید. [توضیحات بیشتر ...](https://apigee.com/about/blog/technology/restful-api-design-what-about-errors)

- تعداد کل منابع/دیتا را در پاسخ (response) خود اعلام کنید.
- پارامترهای `limit` و `offset` را بپذیرید.

- مقدار داده‌ای که یک منبع در پاسخ ارائه می‌دهد نیز باید مورد توجه قرار گیرد. مصرف‌کننده API همیشه به تمام اطلاعات مربوط به یک منبع نیاز ندارد. از پارامتر fields استفاده کنید که لیستی از فیلدها را به صورت جدا شده با کاما دریافت می‌کند تا مشخص کند کدام فیلدها در پاسخ گنجانده شوند:

```
GET /students?fields=id,name,age,class
```

- پشتیبانی از صفحه‌بندی (pagination)، فیلتر کردن (filtering) و مرتب‌سازی (sorting) نیازی نیست از ابتدا برای همه منابع (resourceها) فعال باشد. منابعی که این قابلیت را دارند، باید به طور مستند (از طریق Document) مشخص شوند.

<a name="api-security"></a>

### 9.2 امنیت ای‌پی‌آی/API security

این موارد برخی از بهترین روش‌های امنیتی پایه هستند:

- از احراز هویت پایه (Basic Authentication) استفاده نکنید، مگر اینکه از یک اتصال امن (HTTPS) استفاده کنید. توکن‌های احراز هویت نباید در URL منتقل شوند: `GET /users/123?token=asdf....`

_چرا:_

> زیرا توکن یا شناسه کاربری و رمز عبور به صورت متن ساده (clear text) در شبکه ارسال می‌شوند (اگرچه به صورت Base64 کدگذاری شده است، اما Base64 یک کدگذاری برگشت‌پذیر است). بنابراین، روش احراز هویت پایه ایمن نیست. [توضیحات بیشتر ...](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication)

- توکن‌ها باید با استفاده از هدر Authorization در هر درخواست منتقل شوند: `Authorization: Bearer xxxxxx, Extra yyyyy`.
- کدهای Authorization باید مدت‌زمان کوتاهی معتبر باشند.
- هرگونه درخواست بدون TLS را رد کنید. به درخواست‌های HTTP (بدون TSL) پاسخ ندهید تا از تبادل داده‌های ناامن جلوگیری شود. اگر پاسخ می‌دهید، از کد وضعیت `403 Forbidden` استفاده کنید.
- استفاده از نرخ محدودیت (Rate Limiting) را در نظر بگیرید.

_چرا:_

> برای حفاظت از API در برابر تهدیدات بات‌هایی که ممکن است هزاران بار در ساعت API شما را فراخوانی می‌کنند. باید محدودیت نرخ (rate limit) را از همان مراحل اولیه پیاده‌سازی مد نظر قرار دهید.

- تنظیم مناسب هدرهای HTTP می‌تواند به ایمن‌سازی برنامه وب شما کمک کند. [توضیحات بیشتر ...](https://github.com/helmetjs/helmet)
- API شما باید داده‌های دریافت‌شده را به فرم استانداردشان تبدیل کند یا آن‌ها را رد کند. در صورت وجود داده‌های نادرست یا ناقص، کد وضعیت 400 Bad Request را همراه با جزئیات خطا در پاسخ بازگردانید.
- تمام داده‌های مبادله‌شده با REST API باید توسط خود API اعتبارسنجی شوند.
- JSON خود را سریالایز (Serialize) کنید.

_چرا:_

> یکی از نگرانی‌های اصلی کار با JSON، جلوگیری از اجرای کدهای جاوااسکریپت دلخواه از remote در مرورگر است... یا اگر از node.js در سمت سرور استفاده می‌کنید. بسیار مهم و حیاتی است که از یک سریالایزر JSON مناسب استفاده کنید تا داده‌های ورودی کاربر به درستی کدگذاری شوند و از اجرای داده‌های ورودی کاربر در مرورگر جلوگیری شود.

- نوع محتوا (Content-Type) را اعتبارسنجی کنید و بیشتر از `application/*json` (هدر Content-Type) استفاده کنید.

_چرا:_

> به عنوان مثال، پذیرش نوع `application/x-www-form-urlencoded` به مهاجم اجازه می‌دهد یک فرم ایجاد کند و یک درخواست POST ساده ارسال کند. سرور هرگز نباید نوع محتوا (Content-Type) را فرض کند. عدم وجود هدر Content-Type یا وجود یک Content-Type غیرمنتظره باید منجر به رد محتوا توسط سرور با یک پاسخ `4XX` شود.

- پروژه API Security Checklist را بررسی کنید. [توضیحات بیشتر ...](https://github.com/shieldfy/API-Security-Checklist)

<a name="api-documentation"></a>

### 9.3 مستندسازی ای‌پی‌آی/API documentation

- بخش `API Reference` را در [README.md template](./README.sample.md) برای API پر کنید.
- روش‌های احراز هویت API را با یک نمونه کد توضیح دهید.
- ساختار URL (فقط path بدون root URL) را به همراه نوع درخواست (Method) شرح دهید.

برای هر Endpoint، موارد زیر را توضیح دهید:

- اگر پارامترهای URL وجود دارند، آن‌ها را مطابق با نام ذکر شده در بخش URL مشخص کنید:

```
Required: id=[integer]
Optional: photo_id=[alphanumeric]
```

- اگر نوع درخواست POST است، نمونه‌های کاربردی ارائه دهید. قوانین پارامترهای URL در اینجا نیز اعمال می‌شوند. این بخش را به دو دسته اختیاری و الزامی تقسیم کنید.
- پاسخ موفقیت‌آمیز (Success Response)، کد وضعیت (Status Code) چه باید باشد و آیا داده‌ای در پاسخ بازگردانده می‌شود یا خیر؟ این اطلاعات زمانی مفید است که کاربران نیاز دارند بدانند چه چیزی از پاسخ دریافت خواهند کرد:

```
Code: 200
Content: { id : 12 }
```

- پاسخ خطا (Error Response)، بیشتر endpointها ممکن است به روش‌های مختلفی شکست بخورند. از دسترسی غیرمجاز گرفته تا پارامترهای اشتباه و غیره. تمامی این موارد باید در این بخش لیست شوند. ممکن است تکراری به نظر برسد، اما از ایجاد فرضیات جلوگیری می‌کند. به عنوان مثال:

```json
{
	"code": 401,
	"message": "Authentication failed",
	"description": "Invalid username or password"
}
```

- از ابزارهای طراحی API استفاده کنید؛ ابزارهای متن‌باز زیادی برای مستندسازی خوب وجود دارند، مانند [API Blueprint](https://apiblueprint.org/) و [Swagger](https://swagger.io/).

<a name="a11y"></a>

## 10. دسترس‌پذیری/Accessibility ([a11y](https://www.a11yproject.com/))

<p align="right">
  <img src="/images/accessibility.png" alt="Accessibility" width="128" height="128">
</p>

### 10.1 پیاده‌سازی روش‌های دسترسی‌پذیری

برای اطمینان از حفظ سطح مشخصی از دسترسی‌پذیری، **از ابتدای پروژه خود** مراحل زیر را انجام دهید:

_چرا:_

> محتوای وب [به‌طور پیش‌فرض دسترسی‌پذیر](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/HTML)است. ما این ویژگی را زمانی به خطر می‌اندازیم که امکانات پیچیده ایجاد می‌کنیم. در نظر گرفتن دسترسی‌پذیری از ابتدا بسیار آسان‌تر از بازپیاده‌سازی این ویژگی‌ها در آینده است تا تأثیر آن را کاهش دهیم.

- با استفاده از ابزارهایی مانند [lighthouse](https://developers.google.com/web/tools/lighthouse#devtools) برای [دسترسی‌پذیری](https://web.dev/lighthouse-accessibility/) یا افزونه [axe DevTools](https://chrome.google.com/webstore/detail/axe-devtools-web-accessib/lhdoppojpmngadmnindnejefpokejbdd?hl=en-US)برنامه‌ریزی‌هایی را جهت انجام ممیزی‌های منظم انجام دهید. بر اساس نیازهای پروژه خود، بر روی یک امتیاز حداقلی توافق کنید. امتیازدهی در این ابزارها بر اساس [ارزیابی تأثیر کاربر در axe](https://github.com/dequelabs/axe-core/blob/develop/doc/rule-descriptions.md#wcag-21-level-a--aa-rules) می‌باشد.

> **نکته:** [برخی بررسی‌های مهم](https://web.dev/lighthouse-accessibility/#additional-items-to-manually-check) باید به‌صورت دستی انجام شوند، مانند ترتیب منطقی تب‌ها. ابزارهای فوق این موارد را به عنوان تست‌های دستی یا راهنمایی‌شده در کنار نتایج خودکار فهرست می‌کنند. در axe باید نتایج خودکار خود را ذخیره کنید تا این موارد را مشاهده کنید.

- یک Linter مرتبط با دسترس‌پذیری نصب کنید:
  - در ری‌اکت: [eslint-plugin-jsx-a11y](https://www.npmjs.com/package/eslint-plugin-jsx-a11y)
  - در انگولار: [Angular Codelyzer](https://github.com/mgechev/codelyzer)
  - در ویو: [eslint-plugin-vuejs-accessibility](https://github.com/vue-a11y/eslint-plugin-vuejs-accessibility)

_چرا:_

> یک لینتر به‌طور خودکار بررسی می‌کند که سطح پایه‌ای از دسترسی‌پذیری در پروژه شما رعایت شده است و راه‌اندازی آن نسبتاً آسان است.

- با استفاده از [axe-core](https://www.youtube.com/watch?v=-n5Ul7WPc3Y&list=PLMlWGnpsViOMt24a-Y_dybv68H-kj6Un6&t=1649s) یا ابزارهای مشابه، تست‌های دسترسی‌پذیری را راه‌اندازی و اجرا کنید.
- اگر از Storybook استفاده می‌کنید، این [راهنما](https://storybook.js.org/blog/accessibility-testing-with-storybook/) را دنبال کنید.

_چرا:_

> گنجاندن بررسی‌های دسترس‌پذیری در تست‌ها به شما کمک می‌کند تا هر تغییری که بر دسترس‌پذیری پروژه و امتیاز ممیزی تأثیر می‌گذارد، شناسایی کنید.

- از یک دیزان سیستم دسترسی‌پذیر مانند [React Spectrum](https://react-spectrum.adobe.com/react-spectrum/) یا [Material Design](https://material.io/design) استفاده کنید.

_چرا:_

> این کامپوننت‌ها به صورت پیش‌فرض از سطح بالایی از دسترس‌پذیری برخوردار هستند.

### 10.2 برخی از قوانین پایه دسترس‌پذیری که باید به پروژه خود اضافه کنید:

- اطمینان حاصل کنید که نام لینک‌ها دسترس‌پذیر هستند. از aria-label برای توصیف لینک‌ها استفاده کنید.

_چرا:_

> لینک‌هایی که غیرقابل دسترس می‌باشند، برای دسترس‌پذیری موانعی ایجاد می‌کنند.

- اطمینان حاصل کنید که لیست‌ها به‌درستی ساختاربندی شده باشند و عناصر لیست به صورت معنایی استفاده شده‌اند.

_چرا:_

> لیست‌ها باید دارای عناصر والد و عناصر فرزند باشند تا معتبر باشند. صفحه‌خوان‌ها (Screen Readers) به کاربران اطلاع می‌دهند که وقتی به یک لیست می‌رسند، لیست شامل چند آیتم است.

- اطمینان حاصل کنید که ترتیب سرفصل‌ها (Heading Order) از نظر معنایی صحیح است.

_چرا:_

> سرفصل‌ها ساختار صفحه را منتقل می‌کنند. هنگامی که به درستی اعمال شوند، پیمایش صفحه آسان‌تر می‌شود.

- اطمینان حاصل کنید که عناصر متنی دارای کنتراست کافی با پس‌زمینه‌ی صفحه هستند.

_چرا:_

> برخی افراد با بینایی کم، کنتراست پایین را تجربه می‌کنند؛ به این معنی که تفاوت زیادی بین مناطق روشن و تاریک وجود ندارد. همه چیز تقریباً با همان میزان روشنایی ظاهر می‌شود، که تشخیص خطوط، حاشیه‌ها، لبه‌ها و جزئیات را دشوار می‌کند. متنی که از نظر روشنایی بسیار نزدیک به پس‌زمینه باشد، ممکن است سخت خوانده شود.

- برای تصاویر، متن جایگزین (Alt Text) ارائه دهید.

_چرا:_

> صفحه‌خوان‌ها نمی‌توانند تصاویر را به کلماتی تبدیل کنند که برای کاربر خوانده شود، حتی اگر تصویر فقط شامل متن باشد. در نتیجه، ضروری است که تصاویر دارای متن جایگزین کوتاه و توصیفی باشند تا کاربران صفحه‌خوان به‌وضوح محتوای تصویر و هدف آن را درک کنند.

قوانین بیشتری درباره دسترس‌پذیری را می‌توانید [اینجا](https://dequeuniversity.com/rules/axe) پیدا کنید.

<a name="licensing"></a>

## 11. مجوزدهی/Licensing

<p align="right">
  <img src="/images/licensing.png" alt="Licensing" width="135" height="135">
</p>

اطمینان حاصل کنید که از منابعی استفاده می‌کنید که حق استفاده از آن‌ها را دارید. اگر از کتابخانه‌ها استفاده می‌کنید، به مجوزهای MIT، Apache یا BSD توجه کنید، اما اگر این کتابخانه‌ها را تغییر می‌دهید، حتماً جزئیات مجوز را بررسی کنید. استفاده از تصاویر و ویدئوهای دارای حق کپی‌رایت (Copyrighted) ممکن است مشکلات قانونی ایجاد کند.

---

منابع:
[RisingStack Engineering](https://blog.risingstack.com/),
[Mozilla Developer Network](https://developer.mozilla.org/),
[Heroku Dev Center](https://devcenter.heroku.com),
[Airbnb/javascript](https://github.com/airbnb/javascript),
[Atlassian Git tutorials](https://www.atlassian.com/git/tutorials),
[Apigee](https://apigee.com/about/blog),
[Wishtack](https://blog.wishtack.com)

Icons by [icons8](https://icons8.com/)
